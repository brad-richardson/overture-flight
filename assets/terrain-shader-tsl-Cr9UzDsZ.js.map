{"version":3,"mappings":"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","names":["tslModule","webgpuModule","loadTSL","__vitePreload","loadWebGPU","createTSLTerrainMaterial","config","TSL","MeshStandardNodeMaterial","elevationMapUniform","vertExaggerationUniform","tileCenterUniform","THREE.Vector2","tileDimensionsUniform","texelSizeUniform","worldToTileUV","worldPos2","normalizedPos","sampleElevation","uv","computeTerrainNormal","hL","hR","hD","hU","dX","dZ","positionNode","pos","worldPos","elevation","isSkirt","skirtY","normalY","finalY","normalNode","terrainNormal","material","THREE.DoubleSide","colorTextureNode","texture","createElevationDataTextureWebGPU","heights","size","float16Data","i","toHalf","THREE.DataTexture","THREE.RedFormat","THREE.HalfFloatType","THREE.LinearFilter","THREE.ClampToEdgeWrapping","value","floatView","int32View","x","sign","exponent","mantissa"],"ignoreList":[],"sources":["../../src/ground-texture/terrain-shader-tsl.ts"],"sourcesContent":["/**\n * TSL (Three.js Shading Language) terrain displacement for WebGPU\n *\n * Provides GPU terrain displacement using node-based materials\n * compatible with WebGPURenderer.\n *\n * This module is dynamically imported only when WebGPU is active\n * to avoid bundling WebGPU code in the WebGL build.\n */\n\nimport * as THREE from 'three';\n\n// WebGPU module types (dynamically imported)\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype TSLModule = any;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype WebGPUModule = any;\n\n// Cached module references\nlet tslModule: TSLModule | null = null;\nlet webgpuModule: WebGPUModule | null = null;\n\n/**\n * Load TSL module for node shader functions\n */\nasync function loadTSL(): Promise<TSLModule> {\n  if (!tslModule) {\n    tslModule = await import('three/tsl');\n  }\n  return tslModule;\n}\n\n/**\n * Get cached TSL module (must call loadTSL first)\n */\nexport function getTSLModule(): TSLModule {\n  if (!tslModule) {\n    throw new Error('TSL module not loaded. Call loadTSL() first.');\n  }\n  return tslModule;\n}\n\n/**\n * Load WebGPU module for node materials\n */\nasync function loadWebGPU(): Promise<WebGPUModule> {\n  if (!webgpuModule) {\n    webgpuModule = await import('three/webgpu');\n  }\n  return webgpuModule;\n}\n\n/**\n * Configuration for TSL terrain material\n */\nexport interface TSLTerrainConfig {\n  /** Elevation data texture (Float32 or HalfFloat, single channel) */\n  elevationTexture: THREE.DataTexture;\n  /** Vertical exaggeration factor */\n  verticalExaggeration: number;\n  /** World position of elevation tile center */\n  tileCenter: THREE.Vector3;\n  /** Dimensions of the elevation tile in world units */\n  tileDimensions: {\n    width: number;\n    height: number;\n  };\n  /** Optional color texture to apply */\n  colorTexture?: THREE.Texture;\n}\n\n/**\n * Result of creating a TSL terrain material\n */\nexport interface TSLTerrainMaterialResult {\n  material: THREE.Material;\n  /** Method to update the color texture after material creation */\n  setColorTexture: (texture: THREE.Texture) => void;\n}\n\n/**\n * Create a WebGPU-compatible terrain material with elevation displacement\n *\n * Uses MeshStandardNodeMaterial for full PBR support including:\n * - Vertex position displacement based on elevation texture\n * - Terrain normals computed from elevation gradient\n * - Standard material properties (roughness, metalness, shadows)\n */\nexport async function createTSLTerrainMaterial(\n  config: TSLTerrainConfig\n): Promise<TSLTerrainMaterialResult> {\n  // Load both modules - TSL for node functions, WebGPU for material classes\n  const TSL = await loadTSL();\n  const { MeshStandardNodeMaterial } = await loadWebGPU();\n\n  // Create uniform nodes for elevation sampling\n  const elevationMapUniform = TSL.texture(config.elevationTexture);\n  const vertExaggerationUniform = TSL.uniform(config.verticalExaggeration);\n  const tileCenterUniform = TSL.uniform(\n    new THREE.Vector2(config.tileCenter.x, config.tileCenter.z)\n  );\n  const tileDimensionsUniform = TSL.uniform(\n    new THREE.Vector2(config.tileDimensions.width, config.tileDimensions.height)\n  );\n\n  // Calculate texel size for normal computation (1 texel in world units)\n  const texelSizeUniform = TSL.uniform(\n    Math.max(config.tileDimensions.width, config.tileDimensions.height) / 256.0\n  );\n\n  // Helper function: Convert world position to normalized tile UV coordinates\n  const worldToTileUV = TSL.Fn(([worldPos2]: [any]) => {\n    const localPos = worldPos2.sub(tileCenterUniform);\n    const normalizedPos = localPos.div(tileDimensionsUniform).add(0.5);\n    // Clamp to valid texture range (ClampToEdgeWrapping handles edge pixels)\n    return TSL.clamp(normalizedPos, 0.0, 1.0);\n  });\n\n  // Helper function: Sample elevation at a world position\n  const sampleElevation = TSL.Fn(([worldPos2]: [any]) => {\n    const uv = worldToTileUV(worldPos2);\n    // Sample red channel of elevation texture\n    const elevation = elevationMapUniform.uv(uv).r;\n    return elevation.mul(vertExaggerationUniform);\n  });\n\n  // Helper function: Compute terrain normal from elevation gradient using finite differences\n  const computeTerrainNormal = TSL.Fn(([worldPos2]: [any]) => {\n    // Sample neighboring elevations\n    const hL = sampleElevation(worldPos2.add(TSL.vec2(texelSizeUniform.negate(), 0.0)));\n    const hR = sampleElevation(worldPos2.add(TSL.vec2(texelSizeUniform, 0.0)));\n    const hD = sampleElevation(worldPos2.add(TSL.vec2(0.0, texelSizeUniform.negate())));\n    const hU = sampleElevation(worldPos2.add(TSL.vec2(0.0, texelSizeUniform)));\n\n    // Compute gradient (change in elevation per world unit)\n    const dX = hR.sub(hL).div(texelSizeUniform.mul(2.0));\n    const dZ = hU.sub(hD).div(texelSizeUniform.mul(2.0));\n\n    // Normal from gradient (Y-up coordinate system)\n    // The normal points in the direction perpendicular to the surface\n    return TSL.normalize(TSL.vec3(dX.negate(), 1.0, dZ.negate()));\n  });\n\n  // Position node: Displaces vertex Y based on sampled elevation\n  // Handles terrain skirts: vertices with Y < 0 extend below terrain\n  const positionNode = TSL.Fn(() => {\n    const pos = TSL.positionLocal;\n\n    // Transform to world space to get world coordinates for elevation sampling\n    const worldPos = TSL.modelWorldMatrix.mul(TSL.vec4(pos, 1.0));\n    const worldPos2 = TSL.vec2(worldPos.x, worldPos.z);\n\n    // Sample elevation at this world position\n    const elevation = sampleElevation(worldPos2);\n\n    // Check if this is a skirt bottom vertex (original Y < -0.5)\n    // Skirt bottom vertices extend below terrain; normal vertices get displaced to elevation\n    const isSkirt = pos.y.lessThan(-0.5);\n    const skirtY = elevation.add(pos.y); // Extend below terrain\n    const normalY = elevation; // Normal terrain displacement\n\n    // Select Y based on whether this is a skirt vertex\n    const finalY = TSL.select(isSkirt, skirtY, normalY);\n\n    return TSL.vec3(pos.x, finalY, pos.z);\n  })();\n\n  // Normal node: Computes terrain normal from elevation gradient\n  // CRITICAL: Without this, lighting will be broken on displaced terrain\n  // Skirt vertices keep their original outward-pointing normals\n  const normalNode = TSL.Fn(() => {\n    const pos = TSL.positionLocal;\n\n    // Transform to world space\n    const worldPos = TSL.modelWorldMatrix.mul(TSL.vec4(pos, 1.0));\n    const worldPos2 = TSL.vec2(worldPos.x, worldPos.z);\n\n    // Compute terrain normal from elevation gradient\n    const terrainNormal = computeTerrainNormal(worldPos2);\n\n    // For skirt vertices, keep original normal (already set in geometry)\n    // For normal vertices, use computed terrain normal\n    const isSkirt = pos.y.lessThan(-0.5);\n    return TSL.select(isSkirt, TSL.normalLocal, terrainNormal);\n  })();\n\n  // Create MeshStandardNodeMaterial with displacement\n  const material = new MeshStandardNodeMaterial();\n  material.positionNode = positionNode;\n  material.normalNode = normalNode;\n  material.roughness = 0.9;\n  material.metalness = 0.0;\n  material.side = THREE.DoubleSide;\n\n  // Apply color texture if provided\n  let colorTextureNode: any = null;\n  if (config.colorTexture) {\n    colorTextureNode = TSL.texture(config.colorTexture);\n    material.colorNode = colorTextureNode;\n  }\n\n  // Method to update color texture after material creation\n  const setColorTexture = (texture: THREE.Texture) => {\n    colorTextureNode = TSL.texture(texture);\n    material.colorNode = colorTextureNode;\n    material.needsUpdate = true;\n  };\n\n  return {\n    material,\n    setColorTexture,\n  };\n}\n\n/**\n * Create elevation DataTexture from height data for WebGPU\n *\n * Uses HalfFloatType for wider WebGPU device compatibility.\n * Float32 with linear filtering requires the 'float32-filterable' feature\n * which is not universally supported.\n */\nexport function createElevationDataTextureWebGPU(\n  heights: Float32Array,\n  size: number\n): THREE.DataTexture {\n  // Convert Float32 to Float16 for wider WebGPU compatibility\n  // HalfFloatType is universally supported with linear filtering\n  const float16Data = new Uint16Array(heights.length);\n  for (let i = 0; i < heights.length; i++) {\n    float16Data[i] = toHalf(heights[i]);\n  }\n\n  const texture = new THREE.DataTexture(\n    float16Data,\n    size,\n    size,\n    THREE.RedFormat,\n    THREE.HalfFloatType\n  );\n\n  // Configure for shader sampling\n  texture.minFilter = THREE.LinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.wrapS = THREE.ClampToEdgeWrapping;\n  texture.wrapT = THREE.ClampToEdgeWrapping;\n  texture.needsUpdate = true;\n\n  return texture;\n}\n\n/**\n * Convert a 32-bit float to a 16-bit float (half precision)\n * IEEE 754 half-precision format\n */\nfunction toHalf(value: number): number {\n  const floatView = new Float32Array(1);\n  const int32View = new Int32Array(floatView.buffer);\n\n  floatView[0] = value;\n  const x = int32View[0];\n\n  // Extract components\n  const sign = (x >> 31) & 0x1;\n  let exponent = (x >> 23) & 0xff;\n  let mantissa = x & 0x7fffff;\n\n  // Handle special cases\n  if (exponent === 0xff) {\n    // Inf or NaN\n    return (sign << 15) | 0x7c00 | (mantissa ? 0x200 : 0);\n  }\n\n  if (exponent === 0) {\n    // Zero or denormalized\n    return sign << 15;\n  }\n\n  // Rebias exponent from float32 (bias 127) to float16 (bias 15)\n  exponent = exponent - 127 + 15;\n\n  if (exponent >= 31) {\n    // Overflow to infinity\n    return (sign << 15) | 0x7c00;\n  }\n\n  if (exponent <= 0) {\n    // Underflow to zero\n    return sign << 15;\n  }\n\n  // Normal number\n  mantissa = mantissa >> 13;\n  return (sign << 15) | (exponent << 10) | mantissa;\n}\n"],"file":"assets/terrain-shader-tsl-Cr9UzDsZ.js"}