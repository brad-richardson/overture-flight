{"version":3,"file":"tile-texture.worker-pWYWPwC8.js","sources":["../src/workers/offscreen-renderer.ts","../src/workers/tile-texture.worker.ts"],"sourcesContent":["/**\n * Pure canvas rendering logic for tile textures\n * Works with both HTMLCanvasElement (main thread) and OffscreenCanvas (worker)\n */\n\nimport type { TileBounds, ParsedFeature } from './types.js';\n\n/**\n * Road style configuration\n */\ninterface RoadStyle {\n  color: number;\n  width: number;\n}\n\n/**\n * Canvas type that works in both contexts\n */\ntype AnyCanvas = HTMLCanvasElement | OffscreenCanvas;\ntype AnyContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n/**\n * Colors for different feature types\n */\nconst COLORS: Record<string, number> = {\n  // Water types - blue tones\n  ocean: 0x1e5f8a,\n  sea: 0x1e5f8a,\n  lake: 0x2a7ab0,\n  reservoir: 0x2a7ab0,\n  pond: 0x3388bb,\n  river: 0x2a7ab0,\n  stream: 0x3388bb,\n  canal: 0x2a7ab0,\n  water: 0x1e5f8a,\n\n  // Bathymetry\n  bathymetry: 0x1e5f8a,\n\n  // Land cover types\n  forest: 0x1a4d2e,\n  wood: 0x1e5530,\n  grass: 0x5a8f4a,\n  shrub: 0x3a7a38,\n  crop: 0x8fa858,\n  barren: 0xa08060,\n  wetland: 0x3a6848,\n  swamp: 0x3a6848,\n  mangrove: 0x2a5040,\n  moss: 0x6a8a50,\n  snow: 0xe8f0f8,\n  urban: 0x6a6a6a,\n\n  // Additional land cover\n  park: 0x4a8050,\n  meadow: 0x5a8f4a,\n  farmland: 0x8fa858,\n\n  // Urban/developed (land_use)\n  residential: 0x707070,\n  commercial: 0x787878,\n  industrial: 0x606060,\n\n  // Default land - greenish-gray that blends with forest/grass areas\n  land: 0x8fa880,\n  default: 0x8fa880,\n};\n\n/**\n * Road styles\n */\nconst ROAD_STYLES: Record<string, RoadStyle> = {\n  motorway: { color: 0xa8a090, width: 3.0 },\n  trunk: { color: 0x9a9488, width: 2.5 },\n  primary: { color: 0x8c8880, width: 2.0 },\n  secondary: { color: 0x7e7a74, width: 1.5 },\n  tertiary: { color: 0x706c68, width: 1.2 },\n  residential: { color: 0x666666, width: 0.8 },\n  unclassified: { color: 0x555555, width: 0.6 },\n  service: { color: 0x444444, width: 0.4 },\n  living_street: { color: 0x555555, width: 0.6 },\n  pedestrian: { color: 0x888888, width: 0.5 },\n  footway: { color: 0x777777, width: 0.3 },\n  path: { color: 0x666666, width: 0.3 },\n  cycleway: { color: 0x5a8a5a, width: 0.4 },\n  rail: { color: 0x333333, width: 1.0 },\n  subway: { color: 0x333333, width: 0.8 },\n  tram: { color: 0x333333, width: 0.6 },\n  default: { color: 0x555555, width: 0.5 },\n};\n\n/**\n * Bathymetry depth color stops\n */\nconst BATHYMETRY_COLORS = [\n  { depth: 0, color: { r: 0x4a, g: 0xb0, b: 0xd0 } },\n  { depth: 200, color: { r: 0x3a, g: 0x9a, b: 0xc0 } },\n  { depth: 1000, color: { r: 0x2a, g: 0x80, b: 0xb0 } },\n  { depth: 2000, color: { r: 0x1e, g: 0x5f, b: 0x8a } },\n  { depth: 4000, color: { r: 0x15, g: 0x45, b: 0x70 } },\n  { depth: 6000, color: { r: 0x0d, g: 0x30, b: 0x55 } },\n  { depth: 10000, color: { r: 0x08, g: 0x20, b: 0x40 } },\n];\n\n/**\n * Linear water types to render as lines (not polygons)\n */\nconst LINEAR_WATER_TYPES = ['river', 'stream', 'canal', 'drain', 'ditch', 'waterway'];\n\n/**\n * Ocean/sea subtypes that indicate coastal water\n */\nconst OCEAN_SUBTYPES = ['ocean', 'sea', 'bay', 'strait', 'gulf', 'sound', 'harbour', 'harbor'];\n\n/**\n * Road priority for layering (lower = drawn first/underneath)\n */\nconst ROAD_PRIORITY: Record<string, number> = {\n  service: 0,\n  path: 1,\n  footway: 2,\n  cycleway: 3,\n  pedestrian: 4,\n  unclassified: 5,\n  living_street: 6,\n  residential: 7,\n  tertiary: 8,\n  secondary: 9,\n  primary: 10,\n  trunk: 11,\n  motorway: 12,\n};\n\n/**\n * Convert hex color to CSS string\n */\nfunction hexToCSS(hex: number): string {\n  return '#' + hex.toString(16).padStart(6, '0');\n}\n\n/**\n * Get bathymetry color based on depth\n */\nfunction getBathymetryColor(depth: number): number {\n  const clampedDepth = Math.max(0, Math.min(depth, 10000));\n\n  let lowerStop = BATHYMETRY_COLORS[0];\n  let upperStop = BATHYMETRY_COLORS[BATHYMETRY_COLORS.length - 1];\n\n  for (let i = 0; i < BATHYMETRY_COLORS.length - 1; i++) {\n    if (clampedDepth >= BATHYMETRY_COLORS[i].depth && clampedDepth <= BATHYMETRY_COLORS[i + 1].depth) {\n      lowerStop = BATHYMETRY_COLORS[i];\n      upperStop = BATHYMETRY_COLORS[i + 1];\n      break;\n    }\n  }\n\n  const range = upperStop.depth - lowerStop.depth;\n  const t = range > 0 ? (clampedDepth - lowerStop.depth) / range : 0;\n\n  const r = Math.round(lowerStop.color.r + t * (upperStop.color.r - lowerStop.color.r));\n  const g = Math.round(lowerStop.color.g + t * (upperStop.color.g - lowerStop.color.g));\n  const b = Math.round(lowerStop.color.b + t * (upperStop.color.b - lowerStop.color.b));\n\n  return (r << 16) | (g << 8) | b;\n}\n\n/**\n * Get color for a feature based on layer and properties\n */\nfunction getColorForFeature(layer: string, properties: Record<string, unknown>): number {\n  const subtype = (\n    properties.subtype ||\n    properties.class ||\n    properties.type ||\n    properties.category ||\n    ''\n  ) as string;\n  const type = subtype.toLowerCase();\n\n  if (layer === 'bathymetry') {\n    const depth = typeof properties.depth === 'number' ? properties.depth : 0;\n    return getBathymetryColor(depth);\n  }\n\n  if (layer === 'land_cover') {\n    return COLORS[type] ?? COLORS.grass;\n  }\n\n  if (COLORS[type]) {\n    return COLORS[type];\n  }\n\n  if (layer === 'water') {\n    return COLORS.water;\n  }\n\n  if (layer === 'land') {\n    return COLORS.land;\n  }\n\n  if (layer === 'land_use') {\n    if (type.includes('forest') || type.includes('wood')) return COLORS.forest;\n    if (type.includes('park') || type.includes('recreation')) return COLORS.park;\n    if (type.includes('grass') || type.includes('green') || type.includes('meadow')) return COLORS.grass;\n    if (type.includes('farm') || type.includes('orchard') || type.includes('vineyard')) return COLORS.crop;\n    if (type.includes('water') || type.includes('basin')) return COLORS.water;\n    if (type.includes('residential')) return COLORS.residential;\n    if (type.includes('commercial') || type.includes('retail')) return COLORS.commercial;\n    if (type.includes('industrial')) return COLORS.industrial;\n    if (type.includes('cemetery') || type.includes('grave')) return COLORS.grass;\n    return COLORS.land;\n  }\n\n  return COLORS.default;\n}\n\n/**\n * Get road style based on feature properties\n */\nfunction getRoadStyle(properties: Record<string, unknown> | null): RoadStyle {\n  if (!properties) return ROAD_STYLES.default;\n\n  const roadClass = (properties.class || properties.road_class || properties.highway || '') as string;\n  const type = roadClass.toLowerCase();\n\n  return ROAD_STYLES[type] ?? ROAD_STYLES.default;\n}\n\n/**\n * Create coordinate transform function for tile bounds\n */\nfunction createGeoToCanvas(bounds: TileBounds, size: number): (lng: number, lat: number) => { x: number; y: number } {\n  const lngRange = bounds.east - bounds.west;\n  const latRange = bounds.north - bounds.south;\n\n  return (lng: number, lat: number) => ({\n    x: ((lng - bounds.west) / lngRange) * size,\n    y: ((bounds.north - lat) / latRange) * size,\n  });\n}\n\n/**\n * Draw a single polygon with holes\n */\nfunction drawSinglePolygon(\n  ctx: AnyContext,\n  coords: number[][][],\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (!coords || coords.length === 0) return;\n\n  ctx.beginPath();\n\n  // Outer ring\n  const outer = coords[0];\n  if (!outer || outer.length === 0) return;\n\n  const start = geoToCanvas(outer[0][0], outer[0][1]);\n  ctx.moveTo(start.x, start.y);\n\n  for (let i = 1; i < outer.length; i++) {\n    const pt = geoToCanvas(outer[i][0], outer[i][1]);\n    ctx.lineTo(pt.x, pt.y);\n  }\n  ctx.closePath();\n\n  // Holes (inner rings) - use evenodd fill rule\n  for (let h = 1; h < coords.length; h++) {\n    const hole = coords[h];\n    if (!hole || hole.length === 0) continue;\n\n    const holeStart = geoToCanvas(hole[0][0], hole[0][1]);\n    ctx.moveTo(holeStart.x, holeStart.y);\n\n    for (let i = 1; i < hole.length; i++) {\n      const pt = geoToCanvas(hole[i][0], hole[i][1]);\n      ctx.lineTo(pt.x, pt.y);\n    }\n    ctx.closePath();\n  }\n}\n\n/**\n * Draw a polygon (with holes) on canvas\n */\nfunction drawPolygon(\n  ctx: AnyContext,\n  coordinates: number[][][] | number[][][][],\n  featureType: string,\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (featureType === 'Polygon') {\n    drawSinglePolygon(ctx, coordinates as number[][][], geoToCanvas);\n  } else if (featureType === 'MultiPolygon') {\n    for (const polygon of coordinates as number[][][][]) {\n      drawSinglePolygon(ctx, polygon, geoToCanvas);\n    }\n  }\n}\n\n/**\n * Draw a single line\n */\nfunction drawSingleLine(\n  ctx: AnyContext,\n  coords: number[][],\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (!coords || coords.length < 2) return;\n\n  ctx.beginPath();\n  const start = geoToCanvas(coords[0][0], coords[0][1]);\n  ctx.moveTo(start.x, start.y);\n\n  for (let i = 1; i < coords.length; i++) {\n    const pt = geoToCanvas(coords[i][0], coords[i][1]);\n    ctx.lineTo(pt.x, pt.y);\n  }\n\n  ctx.stroke();\n}\n\n/**\n * Draw a line string on canvas\n */\nfunction drawLineString(\n  ctx: AnyContext,\n  coordinates: number[][] | number[][][],\n  featureType: string,\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (featureType === 'LineString') {\n    drawSingleLine(ctx, coordinates as number[][], geoToCanvas);\n  } else if (featureType === 'MultiLineString') {\n    for (const line of coordinates as number[][][]) {\n      drawSingleLine(ctx, line, geoToCanvas);\n    }\n  }\n}\n\n/**\n * Render all features for a tile to a canvas\n * Works with both HTMLCanvasElement and OffscreenCanvas\n */\nexport function renderTileTextureToCanvas(\n  canvas: AnyCanvas,\n  baseFeatures: ParsedFeature[],\n  transportFeatures: ParsedFeature[],\n  bounds: TileBounds\n): void {\n  const size = canvas.width;\n  const ctx = canvas.getContext('2d') as AnyContext;\n  if (!ctx) return;\n\n  // Enable antialiasing\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n\n  const geoToCanvas = createGeoToCanvas(bounds, size);\n\n  // Calculate meters per pixel for road width scaling\n  const tileSizeMeters = (bounds.east - bounds.west) * 111320 * Math.cos(((bounds.north + bounds.south) / 2) * Math.PI / 180);\n  const metersPerPixel = tileSizeMeters / size;\n\n  // Separate features by layer first to determine base color\n  const landFeatures: ParsedFeature[] = [];\n  const landUseFeatures: ParsedFeature[] = [];\n  const landCoverFeatures: ParsedFeature[] = [];\n  const waterLineFeatures: ParsedFeature[] = [];\n  const waterBodyFeatures: ParsedFeature[] = [];\n  const oceanFeatures: ParsedFeature[] = [];\n\n  for (const feature of baseFeatures) {\n    const layer = feature.layer;\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n\n    if (layer === 'land') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        landFeatures.push(feature);\n      }\n    } else if (layer === 'land_use') {\n      landUseFeatures.push(feature);\n    } else if (layer === 'land_cover') {\n      landCoverFeatures.push(feature);\n    } else if (layer === 'water') {\n      if (feature.type === 'LineString' || feature.type === 'MultiLineString') {\n        if (LINEAR_WATER_TYPES.includes(subtype)) {\n          waterLineFeatures.push(feature);\n        }\n      } else if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        const isFromLowerZoom = feature.properties._fromLowerZoom === true;\n        if (OCEAN_SUBTYPES.includes(subtype) || isFromLowerZoom) {\n          oceanFeatures.push(feature);\n        } else {\n          waterBodyFeatures.push(feature);\n        }\n      }\n    }\n  }\n\n  // Detect if this is an open ocean tile\n  const isOpenOceanTile = oceanFeatures.length > 0 && landFeatures.length < 10;\n\n  // === Layer 0: Base fill ===\n  if (isOpenOceanTile) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    ctx.fillRect(0, 0, size, size);\n  } else {\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    ctx.fillRect(0, 0, size, size);\n  }\n\n  // === Layer 1: Land polygons (for open ocean tiles) ===\n  if (isOpenOceanTile && landFeatures.length > 0) {\n    ctx.save();\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    for (const feature of landFeatures) {\n      drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n      ctx.fill('evenodd');\n    }\n    ctx.restore();\n  }\n\n  // === Layer 2: Land use ===\n  ctx.save();\n  for (const feature of landUseFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_use', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 3: Land cover ===\n  ctx.save();\n  for (const feature of landCoverFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_cover', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 4: Water lines (rivers/streams) ===\n  // Render with wider strokes since river polygons often don't exist at lower zoom levels\n  ctx.save();\n  ctx.strokeStyle = hexToCSS(COLORS.river);\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  for (const feature of waterLineFeatures) {\n    // Use subtype to determine line width: rivers are wider than streams\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n    let widthMeters: number;\n    if (subtype === 'river') {\n      widthMeters = 20; // Major rivers\n    } else if (subtype === 'stream' || subtype === 'drain' || subtype === 'ditch') {\n      widthMeters = 3;\n    } else if (subtype === 'canal') {\n      widthMeters = 12;\n    } else {\n      widthMeters = 8; // Default width for unknown or unclassified water lines\n    }\n    ctx.lineWidth = Math.max(2, widthMeters / metersPerPixel);\n    drawLineString(ctx, feature.coordinates as number[][] | number[][][], feature.type, geoToCanvas);\n  }\n  ctx.restore();\n\n  // === Layer 5: Water bodies (ocean + inland) ===\n  ctx.save();\n  for (const feature of oceanFeatures) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  for (const feature of waterBodyFeatures) {\n    const color = getColorForFeature('water', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 6: Roads ===\n  const roadFeatures = transportFeatures\n    .filter(f => {\n      if (f.layer === 'connector') return false;\n      if (f.layer !== 'segment') return false;\n      if (f.type !== 'LineString' && f.type !== 'MultiLineString') return false;\n      if (f.properties?.subtype !== 'road') return false;\n\n      const props = f.properties as Record<string, unknown>;\n\n      // Check road_flags for is_tunnel\n      if (typeof props.road_flags === 'string') {\n        try {\n          const flags = JSON.parse(props.road_flags) as Array<{ values?: string[] }>;\n          const hasTunnel = flags.some(flag => flag.values?.includes('is_tunnel'));\n          if (hasTunnel) return false;\n        } catch {\n          // Ignore parse errors\n        }\n      }\n\n      // Check level_rules for negative levels\n      if (typeof props.level_rules === 'string') {\n        try {\n          const rules = JSON.parse(props.level_rules) as Array<{ value?: number }>;\n          const hasNegativeLevel = rules.length > 0 && rules.every(rule =>\n            typeof rule.value === 'number' && rule.value < 0\n          );\n          if (hasNegativeLevel) return false;\n        } catch {\n          // Ignore parse errors\n        }\n      }\n\n      if (props.is_tunnel === true || props.is_underground === true) return false;\n      if (typeof props.level === 'number' && props.level < 0) return false;\n\n      return true;\n    })\n    .sort((a, b) => {\n      const classA = ((a.properties?.class || 'default') as string).toLowerCase();\n      const classB = ((b.properties?.class || 'default') as string).toLowerCase();\n      return (ROAD_PRIORITY[classA] ?? 5) - (ROAD_PRIORITY[classB] ?? 5);\n    });\n\n  ctx.save();\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  for (const feature of roadFeatures) {\n    const style = getRoadStyle(feature.properties);\n    const widthPixels = Math.max(1, (style.width * 5) / metersPerPixel);\n\n    ctx.strokeStyle = hexToCSS(style.color);\n    ctx.lineWidth = widthPixels;\n    drawLineString(ctx, feature.coordinates as number[][] | number[][][], feature.type, geoToCanvas);\n  }\n  ctx.restore();\n}\n\n/**\n * Render simplified features for a low-detail distant tile\n * Works with both HTMLCanvasElement and OffscreenCanvas\n */\nexport function renderLowDetailTextureToCanvas(\n  canvas: AnyCanvas,\n  baseFeatures: ParsedFeature[],\n  bounds: TileBounds\n): void {\n  const size = canvas.width;\n  const ctx = canvas.getContext('2d') as AnyContext;\n  if (!ctx) return;\n\n  // Enable antialiasing\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n\n  const geoToCanvas = createGeoToCanvas(bounds, size);\n\n  // Separate features by layer\n  const landFeatures: ParsedFeature[] = [];\n  const landCoverFeatures: ParsedFeature[] = [];\n  const waterBodyFeatures: ParsedFeature[] = [];\n  const oceanFeatures: ParsedFeature[] = [];\n\n  for (const feature of baseFeatures) {\n    const layer = feature.layer;\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n\n    if (layer === 'land') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        landFeatures.push(feature);\n      }\n    } else if (layer === 'land_cover') {\n      landCoverFeatures.push(feature);\n    } else if (layer === 'water') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        const isFromLowerZoom = feature.properties._fromLowerZoom === true;\n        if (OCEAN_SUBTYPES.includes(subtype) || isFromLowerZoom) {\n          oceanFeatures.push(feature);\n        } else {\n          waterBodyFeatures.push(feature);\n        }\n      }\n    }\n  }\n\n  // Detect if this is an open ocean tile\n  const isOpenOceanTile = oceanFeatures.length > 0 && landFeatures.length < 10;\n\n  // === Layer 0: Base fill ===\n  if (isOpenOceanTile) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    ctx.fillRect(0, 0, size, size);\n  } else {\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    ctx.fillRect(0, 0, size, size);\n  }\n\n  // === Layer 1: Land polygons (for open ocean tiles) ===\n  if (isOpenOceanTile && landFeatures.length > 0) {\n    ctx.save();\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    for (const feature of landFeatures) {\n      drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n      ctx.fill('evenodd');\n    }\n    ctx.restore();\n  }\n\n  // === Layer 2: Land cover ===\n  ctx.save();\n  for (const feature of landCoverFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_cover', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 3: Water bodies ===\n  ctx.save();\n  for (const feature of oceanFeatures) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  for (const feature of waterBodyFeatures) {\n    const color = getColorForFeature('water', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n}\n","/**\n * Web Worker for tile texture rendering\n * Offloads CPU-intensive canvas operations from the main thread\n */\n\nimport type { WorkerRequest, WorkerResponse } from './types.js';\nimport { renderTileTextureToCanvas, renderLowDetailTextureToCanvas } from './offscreen-renderer.js';\n\n// Test OffscreenCanvas capability on worker startup\nlet offscreenCanvasSupported = false;\ntry {\n  const testCanvas = new OffscreenCanvas(1, 1);\n  const testCtx = testCanvas.getContext('2d');\n  offscreenCanvasSupported = testCtx !== null;\n} catch {\n  offscreenCanvasSupported = false;\n}\n\n/**\n * Handle incoming messages from the main thread\n */\nself.onmessage = (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case 'CAPABILITY_CHECK': {\n        const response: WorkerResponse = {\n          type: 'CAPABILITY_CHECK_RESULT',\n          id: request.id,\n          supported: offscreenCanvasSupported,\n        };\n        self.postMessage(response);\n        break;\n      }\n\n      case 'RENDER_TILE_TEXTURE': {\n        if (!offscreenCanvasSupported) {\n          const response: WorkerResponse = {\n            type: 'ERROR',\n            id: request.id,\n            error: 'OffscreenCanvas not supported in this worker',\n          };\n          self.postMessage(response);\n          return;\n        }\n\n        const { baseFeatures, transportFeatures, bounds, textureSize } = request.payload;\n\n        // Create OffscreenCanvas and render\n        const canvas = new OffscreenCanvas(textureSize, textureSize);\n        renderTileTextureToCanvas(canvas, baseFeatures, transportFeatures, bounds);\n\n        // Transfer ImageBitmap back to main thread (zero-copy)\n        const bitmap = canvas.transferToImageBitmap();\n        const response: WorkerResponse = {\n          type: 'RENDER_TILE_TEXTURE_RESULT',\n          id: request.id,\n          result: bitmap,\n        };\n        self.postMessage(response, { transfer: [bitmap] });\n        break;\n      }\n\n      case 'RENDER_LOW_DETAIL_TEXTURE': {\n        if (!offscreenCanvasSupported) {\n          const response: WorkerResponse = {\n            type: 'ERROR',\n            id: request.id,\n            error: 'OffscreenCanvas not supported in this worker',\n          };\n          self.postMessage(response);\n          return;\n        }\n\n        const { baseFeatures, bounds, textureSize } = request.payload;\n\n        // Create OffscreenCanvas and render\n        const canvas = new OffscreenCanvas(textureSize, textureSize);\n        renderLowDetailTextureToCanvas(canvas, baseFeatures, bounds);\n\n        // Transfer ImageBitmap back to main thread (zero-copy)\n        const bitmap = canvas.transferToImageBitmap();\n        const response: WorkerResponse = {\n          type: 'RENDER_LOW_DETAIL_TEXTURE_RESULT',\n          id: request.id,\n          result: bitmap,\n        };\n        self.postMessage(response, { transfer: [bitmap] });\n        break;\n      }\n\n      default: {\n        const response: WorkerResponse = {\n          type: 'ERROR',\n          id: (request as { id?: string }).id || 'unknown',\n          error: `Unknown request type: ${(request as { type?: string }).type}`,\n        };\n        self.postMessage(response);\n      }\n    }\n  } catch (error) {\n    const response: WorkerResponse = {\n      type: 'ERROR',\n      id: request.id,\n      error: error instanceof Error ? error.message : 'Unknown error in worker',\n    };\n    self.postMessage(response);\n  }\n};\n\n// Signal that worker is ready\nself.postMessage({ type: 'READY' });\n"],"names":["COLORS","ROAD_STYLES","BATHYMETRY_COLORS","LINEAR_WATER_TYPES","OCEAN_SUBTYPES","ROAD_PRIORITY","hexToCSS","hex","getBathymetryColor","depth","clampedDepth","lowerStop","upperStop","i","range","t","r","g","b","getColorForFeature","layer","properties","type","getRoadStyle","createGeoToCanvas","bounds","size","lngRange","latRange","lng","lat","drawSinglePolygon","ctx","coords","geoToCanvas","outer","start","pt","h","hole","holeStart","drawPolygon","coordinates","featureType","polygon","drawSingleLine","drawLineString","line","renderTileTextureToCanvas","canvas","baseFeatures","transportFeatures","metersPerPixel","landFeatures","landUseFeatures","landCoverFeatures","waterLineFeatures","waterBodyFeatures","oceanFeatures","feature","subtype","isFromLowerZoom","isOpenOceanTile","color","widthMeters","roadFeatures","f","_a","props","flag","rules","rule","a","classA","classB","_b","style","widthPixels","renderLowDetailTextureToCanvas","offscreenCanvasSupported","event","request","response","textureSize","bitmap","error"],"mappings":"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"}