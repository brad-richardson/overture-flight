{"version":3,"file":"full-pipeline.worker-CV9Z4be0.js","sources":["../node_modules/fflate/esm/browser.js","../node_modules/pmtiles/dist/esm/index.js","../node_modules/@mapbox/point-geometry/index.js","../node_modules/@mapbox/vector-tile/index.js","../node_modules/pbf/index.js","../src/workers/offscreen-renderer.ts","../src/workers/full-pipeline.worker.ts"],"sourcesContent":["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","var j=Object.defineProperty;var B=Math.pow;var l=(i,t)=>j(i,\"name\",{value:t,configurable:!0});var m=(i,t,e)=>new Promise((r,n)=>{var s=c=>{try{a(e.next(c))}catch(u){n(u)}},o=c=>{try{a(e.throw(c))}catch(u){n(u)}},a=c=>c.done?r(c.value):Promise.resolve(c.value).then(s,o);a((e=e.apply(i,t)).next())});import{decompressSync as F}from\"fflate\";var re=l((i,t)=>{let e=!1,r=\"\",n=L.GridLayer.extend({createTile:l((s,o)=>{let a=document.createElement(\"img\"),c=new AbortController,u=c.signal;return a.cancel=()=>{c.abort()},e||(i.getHeader().then(d=>{d.tileType===1?console.error(\"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"):d.tileType===2?r=\"image/png\":d.tileType===3?r=\"image/jpeg\":d.tileType===4?r=\"image/webp\":d.tileType===5&&(r=\"image/avif\")}),e=!0),i.getZxy(s.z,s.x,s.y,u).then(d=>{if(d){let h=new Blob([d.data],{type:r}),p=window.URL.createObjectURL(h);a.src=p}else a.style.display=\"none\";a.cancel=void 0,o(void 0,a)}).catch(d=>{if(d.name!==\"AbortError\")throw d}),a},\"createTile\"),_removeTile:l(function(s){let o=this._tiles[s];o&&(o.el.cancel&&o.el.cancel(),o.el.width=0,o.el.height=0,o.el.deleted=!0,L.DomUtil.remove(o.el),delete this._tiles[s],this.fire(\"tileunload\",{tile:o.el,coords:this._keyToTileCoords(s)}))},\"_removeTile\")});return new n(t)},\"leafletRasterLayer\"),W=l(i=>(t,e)=>{if(e instanceof AbortController)return i(t,e);let r=new AbortController;return i(t,r).then(n=>e(void 0,n.data,n.cacheControl||\"\",n.expires||\"\"),n=>e(n)).catch(n=>e(n)),{cancel:l(()=>r.abort(),\"cancel\")}},\"v3compat\"),E=class E{constructor(t){this.tilev4=l((t,e)=>m(this,null,function*(){if(t.type===\"json\"){let p=t.url.substr(10),y=this.tiles.get(p);if(y||(y=new w(p),this.tiles.set(p,y)),this.metadata){let z=yield y.getTileJson(t.url);return e.signal.throwIfAborted(),{data:z}}let f=yield y.getHeader();return e.signal.throwIfAborted(),(f.minLon>=f.maxLon||f.minLat>=f.maxLat)&&console.error(`Bounds of PMTiles archive ${f.minLon},${f.minLat},${f.maxLon},${f.maxLat} are not valid.`),{data:{tiles:[`${t.url}/{z}/{x}/{y}`],minzoom:f.minZoom,maxzoom:f.maxZoom,bounds:[f.minLon,f.minLat,f.maxLon,f.maxLat]}}}let r=new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/),n=t.url.match(r);if(!n)throw new Error(\"Invalid PMTiles protocol URL\");let s=n[1],o=this.tiles.get(s);o||(o=new w(s),this.tiles.set(s,o));let a=n[2],c=n[3],u=n[4],d=yield o.getHeader(),h=yield o==null?void 0:o.getZxy(+a,+c,+u,e.signal);if(e.signal.throwIfAborted(),h)return{data:new Uint8Array(h.data),cacheControl:h.cacheControl,expires:h.expires};if(d.tileType===1){if(this.errorOnMissingTile)throw new Error(\"Tile not found.\");return{data:new Uint8Array}}return{data:null}}),\"tilev4\");this.tile=W(this.tilev4);this.tiles=new Map,this.metadata=(t==null?void 0:t.metadata)||!1,this.errorOnMissingTile=(t==null?void 0:t.errorOnMissingTile)||!1}add(t){this.tiles.set(t.source.getKey(),t)}get(t){return this.tiles.get(t)}};l(E,\"Protocol\");var S=E;function b(i,t){return(t>>>0)*4294967296+(i>>>0)}l(b,\"toNum\");function N(i,t){let e=t.buf,r=e[t.pos++],n=(r&112)>>4;if(r<128||(r=e[t.pos++],n|=(r&127)<<3,r<128)||(r=e[t.pos++],n|=(r&127)<<10,r<128)||(r=e[t.pos++],n|=(r&127)<<17,r<128)||(r=e[t.pos++],n|=(r&127)<<24,r<128)||(r=e[t.pos++],n|=(r&1)<<31,r<128))return b(i,n);throw new Error(\"Expected varint not more than 10 bytes\")}l(N,\"readVarintRemainder\");function x(i){let t=i.buf,e=t[i.pos++],r=e&127;return e<128||(e=t[i.pos++],r|=(e&127)<<7,e<128)||(e=t[i.pos++],r|=(e&127)<<14,e<128)||(e=t[i.pos++],r|=(e&127)<<21,e<128)?r:(e=t[i.pos],r|=(e&15)<<28,N(r,i))}l(x,\"readVarint\");function k(i,t,e,r,n){return n===0?r!==0?[i-1-e,i-1-t]:[e,t]:[t,e]}l(k,\"rotate\");function q(i,t,e){if(i>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");if(t>=1<<i||e>=1<<i)throw new Error(\"tile x/y outside zoom level bounds\");let r=((1<<i)*(1<<i)-1)/3,n=i-1,[s,o]=[t,e];for(let a=1<<n;a>0;a>>=1){let c=s&a,u=o&a;r+=(3*c^u)*(1<<n),[s,o]=k(a,s,o,c,u),n--}return r}l(q,\"zxyToTileId\");function G(i){let t=3*i+1;return t<4294967296?31-Math.clz32(t):63-Math.clz32(t/4294967296)}l(G,\"tileIdToZ\");function ie(i){let t=G(i)>>1;if(t>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");let e=((1<<t)*(1<<t)-1)/3,r=i-e,n=0,s=0,o=1<<t;for(let a=1;a<o;a<<=1){let c=a&r/2,u=a&(r^c);[n,s]=k(a,n,s,c,u),r=r/2,n+=c,s+=u}return[t,n,s]}l(ie,\"tileIdToZxy\");var J=(s=>(s[s.Unknown=0]=\"Unknown\",s[s.None=1]=\"None\",s[s.Gzip=2]=\"Gzip\",s[s.Brotli=3]=\"Brotli\",s[s.Zstd=4]=\"Zstd\",s))(J||{});function D(i,t){return m(this,null,function*(){if(t===1||t===0)return i;if(t===2){if(typeof globalThis.DecompressionStream==\"undefined\")return F(new Uint8Array(i));let e=new Response(i).body;if(!e)throw new Error(\"Failed to read response stream\");let r=e.pipeThrough(new globalThis.DecompressionStream(\"gzip\"));return new Response(r).arrayBuffer()}throw new Error(\"Compression method not supported\")})}l(D,\"defaultDecompress\");var O=(o=>(o[o.Unknown=0]=\"Unknown\",o[o.Mvt=1]=\"Mvt\",o[o.Png=2]=\"Png\",o[o.Jpeg=3]=\"Jpeg\",o[o.Webp=4]=\"Webp\",o[o.Avif=5]=\"Avif\",o))(O||{});function _(i){return i===1?\".mvt\":i===2?\".png\":i===3?\".jpg\":i===4?\".webp\":i===5?\".avif\":\"\"}l(_,\"tileTypeExt\");var Y=127;function Q(i,t){let e=0,r=i.length-1;for(;e<=r;){let n=r+e>>1,s=t-i[n].tileId;if(s>0)e=n+1;else if(s<0)r=n-1;else return i[n]}return r>=0&&(i[r].runLength===0||t-i[r].tileId<i[r].runLength)?i[r]:null}l(Q,\"findTile\");var A=class A{constructor(t){this.file=t}getKey(){return this.file.name}getBytes(t,e){return m(this,null,function*(){return{data:yield this.file.slice(t,t+e).arrayBuffer()}})}};l(A,\"FileSource\");var V=A,C=class C{constructor(t,e=new Headers){var o,a;this.url=t,this.customHeaders=e,this.mustReload=!1;let r=\"\";\"navigator\"in globalThis&&(r=(a=(o=globalThis.navigator)==null?void 0:o.userAgent)!=null?a:\"\");let n=r.indexOf(\"Windows\")>-1,s=/Chrome|Chromium|Edg|OPR|Brave/.test(r);this.chromeWindowsNoCache=!1,n&&s&&(this.chromeWindowsNoCache=!0)}getKey(){return this.url}setHeaders(t){this.customHeaders=t}getBytes(t,e,r,n){return m(this,null,function*(){let s,o;r?o=r:(s=new AbortController,o=s.signal);let a=new Headers(this.customHeaders);a.set(\"range\",`bytes=${t}-${t+e-1}`);let c;this.mustReload?c=\"reload\":this.chromeWindowsNoCache&&(c=\"no-store\");let u=yield fetch(this.url,{signal:o,cache:c,headers:a});if(t===0&&u.status===416){let y=u.headers.get(\"Content-Range\");if(!y||!y.startsWith(\"bytes */\"))throw new Error(\"Missing content-length on 416 response\");let f=+y.substr(8);u=yield fetch(this.url,{signal:o,cache:\"reload\",headers:{range:`bytes=0-${f-1}`}})}let d=u.headers.get(\"Etag\");if(d!=null&&d.startsWith(\"W/\")&&(d=null),u.status===416||n&&d&&d!==n)throw this.mustReload=!0,new v(`Server returned non-matching ETag ${n} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);if(u.status>=300)throw new Error(`Bad response code: ${u.status}`);let h=u.headers.get(\"Content-Length\");if(u.status===200&&(!h||+h>e))throw s&&s.abort(),new Error(\"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\");return{data:yield u.arrayBuffer(),etag:d||void 0,cacheControl:u.headers.get(\"Cache-Control\")||void 0,expires:u.headers.get(\"Expires\")||void 0}})}};l(C,\"FetchSource\");var T=C;function g(i,t){let e=i.getUint32(t+4,!0),r=i.getUint32(t+0,!0);return e*B(2,32)+r}l(g,\"getUint64\");function X(i,t){let e=new DataView(i),r=e.getUint8(7);if(r>3)throw new Error(`Archive is spec version ${r} but this library supports up to spec version 3`);return{specVersion:r,rootDirectoryOffset:g(e,8),rootDirectoryLength:g(e,16),jsonMetadataOffset:g(e,24),jsonMetadataLength:g(e,32),leafDirectoryOffset:g(e,40),leafDirectoryLength:g(e,48),tileDataOffset:g(e,56),tileDataLength:g(e,64),numAddressedTiles:g(e,72),numTileEntries:g(e,80),numTileContents:g(e,88),clustered:e.getUint8(96)===1,internalCompression:e.getUint8(97),tileCompression:e.getUint8(98),tileType:e.getUint8(99),minZoom:e.getUint8(100),maxZoom:e.getUint8(101),minLon:e.getInt32(102,!0)/1e7,minLat:e.getInt32(106,!0)/1e7,maxLon:e.getInt32(110,!0)/1e7,maxLat:e.getInt32(114,!0)/1e7,centerZoom:e.getUint8(118),centerLon:e.getInt32(119,!0)/1e7,centerLat:e.getInt32(123,!0)/1e7,etag:t}}l(X,\"bytesToHeader\");function Z(i){let t={buf:new Uint8Array(i),pos:0},e=x(t),r=[],n=0;for(let s=0;s<e;s++){let o=x(t);r.push({tileId:n+o,offset:0,length:0,runLength:1}),n+=o}for(let s=0;s<e;s++)r[s].runLength=x(t);for(let s=0;s<e;s++)r[s].length=x(t);for(let s=0;s<e;s++){let o=x(t);o===0&&s>0?r[s].offset=r[s-1].offset+r[s-1].length:r[s].offset=o-1}return r}l(Z,\"deserializeIndex\");var U=class U extends Error{};l(U,\"EtagMismatch\");var v=U;function I(i,t){return m(this,null,function*(){let e=yield i.getBytes(0,16384);if(new DataView(e.data).getUint16(0,!0)!==19792)throw new Error(\"Wrong magic number for PMTiles archive\");let n=e.data.slice(0,Y),s=X(n,e.etag),o=e.data.slice(s.rootDirectoryOffset,s.rootDirectoryOffset+s.rootDirectoryLength),a=`${i.getKey()}|${s.etag||\"\"}|${s.rootDirectoryOffset}|${s.rootDirectoryLength}`,c=Z(yield t(o,s.internalCompression));return[s,[a,c.length,c]]})}l(I,\"getHeaderAndRoot\");function K(i,t,e,r,n){return m(this,null,function*(){let s=yield i.getBytes(e,r,void 0,n.etag),o=yield t(s.data,n.internalCompression),a=Z(o);if(a.length===0)throw new Error(\"Empty directory is invalid\");return a})}l(K,\"getDirectory\");var R=class R{constructor(t=100,e=!0,r=D){this.cache=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,r.data;let n=yield I(t,this.decompress);return n[1]&&this.cache.set(n[1][0],{lastUsed:this.counter++,data:n[1][2]}),this.cache.set(e,{lastUsed:this.counter++,data:n[0]}),this.prune(),n[0]})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,o=this.cache.get(s);if(o)return o.lastUsed=this.counter++,o.data;let a=yield K(t,this.decompress,e,r,n);return this.cache.set(s,{lastUsed:this.counter++,data:a}),this.prune(),a})}prune(){if(this.cache.size>this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){this.cache.delete(t.getKey())})}};l(R,\"ResolvedValueCache\");var $=R,M=class M{constructor(t=100,e=!0,r=D){this.cache=new Map,this.invalidations=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,yield r.data;let n=new Promise((s,o)=>{I(t,this.decompress).then(a=>{a[1]&&this.cache.set(a[1][0],{lastUsed:this.counter++,data:Promise.resolve(a[1][2])}),s(a[0]),this.prune()}).catch(a=>{o(a)})});return this.cache.set(e,{lastUsed:this.counter++,data:n}),n})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,o=this.cache.get(s);if(o)return o.lastUsed=this.counter++,yield o.data;let a=new Promise((c,u)=>{K(t,this.decompress,e,r,n).then(d=>{c(d),this.prune()}).catch(d=>{u(d)})});return this.cache.set(s,{lastUsed:this.counter++,data:a}),a})}prune(){if(this.cache.size>=this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){let e=t.getKey();if(this.invalidations.get(e))return yield this.invalidations.get(e);this.cache.delete(t.getKey());let r=new Promise((n,s)=>{this.getHeader(t).then(o=>{n(),this.invalidations.delete(e)}).catch(o=>{s(o)})});this.invalidations.set(e,r)})}};l(M,\"SharedPromiseCache\");var P=M,H=class H{constructor(t,e,r){typeof t==\"string\"?this.source=new T(t):this.source=t,r?this.decompress=r:this.decompress=D,e?this.cache=e:this.cache=new P}getHeader(){return m(this,null,function*(){return yield this.cache.getHeader(this.source)})}getZxyAttempt(t,e,r,n){return m(this,null,function*(){let s=q(t,e,r),o=yield this.cache.getHeader(this.source);if(t<o.minZoom||t>o.maxZoom)return;let a=o.rootDirectoryOffset,c=o.rootDirectoryLength;for(let u=0;u<=3;u++){let d=yield this.cache.getDirectory(this.source,a,c,o),h=Q(d,s);if(h){if(h.runLength>0){let p=yield this.source.getBytes(o.tileDataOffset+h.offset,h.length,n,o.etag);return{data:yield this.decompress(p.data,o.tileCompression),cacheControl:p.cacheControl,expires:p.expires}}a=o.leafDirectoryOffset+h.offset,c=h.length}else return}throw new Error(\"Maximum directory depth exceeded\")})}getZxy(t,e,r,n){return m(this,null,function*(){try{return yield this.getZxyAttempt(t,e,r,n)}catch(s){if(s instanceof v)return this.cache.invalidate(this.source),yield this.getZxyAttempt(t,e,r,n);throw s}})}getMetadataAttempt(){return m(this,null,function*(){let t=yield this.cache.getHeader(this.source),e=yield this.source.getBytes(t.jsonMetadataOffset,t.jsonMetadataLength,void 0,t.etag),r=yield this.decompress(e.data,t.internalCompression),n=new TextDecoder(\"utf-8\");return JSON.parse(n.decode(r))})}getMetadata(){return m(this,null,function*(){try{return yield this.getMetadataAttempt()}catch(t){if(t instanceof v)return this.cache.invalidate(this.source),yield this.getMetadataAttempt();throw t}})}getTileJson(t){return m(this,null,function*(){let e=yield this.getHeader(),r=yield this.getMetadata(),n=_(e.tileType);return{tilejson:\"3.0.0\",scheme:\"xyz\",tiles:[`${t}/{z}/{x}/{y}${n}`],vector_layers:r.vector_layers,attribution:r.attribution,description:r.description,name:r.name,version:r.version,bounds:[e.minLon,e.minLat,e.maxLon,e.maxLat],center:[e.centerLon,e.centerLat,e.centerZoom],minzoom:e.minZoom,maxzoom:e.maxZoom}})}};l(H,\"PMTiles\");var w=H;export{J as Compression,v as EtagMismatch,T as FetchSource,V as FileSource,w as PMTiles,S as Protocol,$ as ResolvedValueCache,P as SharedPromiseCache,O as TileType,X as bytesToHeader,Q as findTile,g as getUint64,re as leafletRasterLayer,x as readVarint,ie as tileIdToZxy,_ as tileTypeExt,q as zxyToTileId};\n//# sourceMappingURL=index.js.map","/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin() for .\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n","\nimport Point from '@mapbox/point-geometry';\n\n/** @import Pbf from 'pbf' */\n/** @import {Feature} from 'geojson' */\n\nexport class VectorTileFeature {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} end\n     * @param {number} extent\n     * @param {string[]} keys\n     * @param {(number | string | boolean)[]} values\n     */\n    constructor(pbf, end, extent, keys, values) {\n        // Public\n\n        /** @type {Record<string, number | string | boolean>} */\n        this.properties = {};\n\n        this.extent = extent;\n        /** @type {0 | 1 | 2 | 3} */\n        this.type = 0;\n\n        /** @type {number | undefined} */\n        this.id = undefined;\n\n        /** @private */\n        this._pbf = pbf;\n        /** @private */\n        this._geometry = -1;\n        /** @private */\n        this._keys = keys;\n        /** @private */\n        this._values = values;\n\n        pbf.readFields(readFeature, this, end);\n    }\n\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n\n        /** @type Point[][] */\n        const lines = [];\n\n        /** @type Point[] | undefined */\n        let line;\n\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n\n                if (cmd === 1) { // moveTo\n                    if (line) lines.push(line);\n                    line = [];\n                }\n\n                if (line) line.push(new Point(x, y));\n\n            } else if (cmd === 7) {\n\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (line) {\n                    line.push(line[0].clone()); // closePolygon\n                }\n\n            } else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        if (line) lines.push(line);\n\n        return lines;\n    }\n\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1,\n            length = 0,\n            x = 0,\n            y = 0,\n            x1 = Infinity,\n            x2 = -Infinity,\n            y1 = Infinity,\n            y2 = -Infinity;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1) x1 = x;\n                if (x > x2) x2 = x;\n                if (y < y1) y1 = y;\n                if (y > y2) y2 = y;\n\n            } else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        return [x1, y1, x2, y2];\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @return {Feature}\n     */\n    toGeoJSON(x, y, z) {\n        const size = this.extent * Math.pow(2, z),\n            x0 = this.extent * x,\n            y0 = this.extent * y,\n            vtCoords = this.loadGeometry();\n\n        /** @param {Point} p */\n        function projectPoint(p) {\n            return [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp((1 - (p.y + y0) * 2 / size) * Math.PI)) - 90\n            ];\n        }\n\n        /** @param {Point[]} line */\n        function projectLine(line) {\n            return line.map(projectPoint);\n        }\n\n        /** @type {Feature[\"geometry\"]} */\n        let geometry;\n\n        if (this.type === 1) {\n            const points = [];\n            for (const line of vtCoords) {\n                points.push(line[0]);\n            }\n            const coordinates = projectLine(points);\n            geometry = points.length === 1 ?\n                {type: 'Point', coordinates: coordinates[0]} :\n                {type: 'MultiPoint', coordinates};\n\n        } else if (this.type === 2) {\n\n            const coordinates = vtCoords.map(projectLine);\n            geometry = coordinates.length === 1 ?\n                {type: 'LineString', coordinates: coordinates[0]} :\n                {type: 'MultiLineString', coordinates};\n\n        } else if (this.type === 3) {\n            const polygons = classifyRings(vtCoords);\n            const coordinates = [];\n            for (const polygon of polygons) {\n                coordinates.push(polygon.map(projectLine));\n            }\n            geometry = coordinates.length === 1 ?\n                {type: 'Polygon', coordinates: coordinates[0]} :\n                {type: 'MultiPolygon', coordinates};\n        } else {\n\n            throw new Error('unknown feature type');\n        }\n\n        /** @type {Feature} */\n        const result = {\n            type: 'Feature',\n            geometry,\n            properties: this.properties\n        };\n\n        if (this.id != null) {\n            result.id = this.id;\n        }\n\n        return result;\n    }\n}\n\n/** @type {['Unknown', 'Point', 'LineString', 'Polygon']} */\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\n/**\n * @param {number} tag\n * @param {VectorTileFeature} feature\n * @param {Pbf} pbf\n */\nfunction readFeature(tag, feature, pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = /** @type {0 | 1 | 2 | 3} */ (pbf.readVarint());\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 4) feature._geometry = pbf.pos;\n}\n\n/**\n * @param {Pbf} pbf\n * @param {VectorTileFeature} feature\n */\nfunction readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        // @ts-expect-error TS2341 deliberately accessing a private property\n        const key = feature._keys[pbf.readVarint()];\n        // @ts-expect-error TS2341 deliberately accessing a private property\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\n/** classifies an array of rings into polygons with outer rings and holes\n * @param {Point[][]} rings\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    const polygons = [];\n    let polygon, ccw;\n\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else if (polygon) {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\n/** @param {Point[]} ring */\nfunction signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\nexport class VectorTileLayer {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n\n        /** @private */\n        this._pbf = pbf;\n\n        /** @private\n         * @type {string[]} */\n        this._keys = [];\n\n        /** @private\n         * @type {(number | string | boolean)[]} */\n        this._values = [];\n\n        /** @private\n         * @type {number[]} */\n        this._features = [];\n\n        pbf.readFields(readLayer, this, end);\n\n        this.length = this._features.length;\n    }\n\n    /** return feature `i` from this layer as a `VectorTileFeature`\n     * @param {number} i\n     */\n    feature(i) {\n        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n        this._pbf.pos = this._features[i];\n\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {VectorTileLayer} layer\n * @param {Pbf} pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 2) layer._features.push(pbf.pos);\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\n/**\n * @param {Pbf} pbf\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n    if (value == null) {\n        throw new Error('unknown feature value');\n    }\n\n    return value;\n}\n\nexport class VectorTile {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        /** @type {Record<string, VectorTileLayer>} */\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {Record<string, VectorTileLayer>} layers\n * @param {Pbf} pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n","\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// Threshold chosen based on both benchmarking and knowledge about browser string\n// data structures (which currently switch structure types at 12 bytes or more)\nconst TEXT_DECODER_MIN_LENGTH = 12;\nconst utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\n\nconst PBF_VARINT  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nconst PBF_FIXED64 = 1; // 64-bit: double, fixed64, sfixed64\nconst PBF_BYTES   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nconst PBF_FIXED32 = 5; // 32-bit: float, fixed32, sfixed32\n\nexport default class Pbf {\n    /**\n     * @param {Uint8Array | ArrayBuffer} [buf]\n     */\n    constructor(buf = new Uint8Array(16)) {\n        this.buf = ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf);\n        this.dataView = new DataView(this.buf.buffer);\n        this.pos = 0;\n        this.type = 0;\n        this.length = this.buf.length;\n    }\n\n    // === READING =================================================================\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     * @param {number} [end]\n     */\n    readFields(readField, result, end = this.length) {\n        while (this.pos < end) {\n            const val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    }\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     */\n    readMessage(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    }\n\n    readFixed32() {\n        const val = this.dataView.getUint32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readSFixed32() {\n        const val = this.dataView.getInt32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readSFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readFloat() {\n        const val = this.dataView.getFloat32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readDouble() {\n        const val = this.dataView.getFloat64(this.pos, true);\n        this.pos += 8;\n        return val;\n    }\n\n    /**\n     * @param {boolean} [isSigned]\n     */\n    readVarint(isSigned) {\n        const buf = this.buf;\n        let val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    }\n\n    readVarint64() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    }\n\n    readSVarint() {\n        const num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    }\n\n    readBoolean() {\n        return Boolean(this.readVarint());\n    }\n\n    readString() {\n        const end = this.readVarint() + this.pos;\n        const pos = this.pos;\n        this.pos = end;\n\n        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n            // longer strings are fast with the built-in browser TextDecoder API\n            return utf8TextDecoder.decode(this.buf.subarray(pos, end));\n        }\n        // short strings are fast with our custom implementation\n        return readUtf8(this.buf, pos, end);\n    }\n\n    readBytes() {\n        const end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    }\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    /**\n     * @param {number[]} [arr]\n     * @param {boolean} [isSigned]\n     */\n    readPackedVarint(arr = [], isSigned) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSVarint(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    }\n    /** @param {boolean[]} [arr] */\n    readPackedBoolean(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFloat(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedDouble(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    }\n    readPackedEnd() {\n        return this.type === PBF_BYTES ? this.readVarint() + this.pos : this.pos + 1;\n    }\n\n    /** @param {number} val */\n    skip(val) {\n        const type = val & 0x7;\n        if (type === PBF_VARINT) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === PBF_BYTES) this.pos = this.readVarint() + this.pos;\n        else if (type === PBF_FIXED32) this.pos += 4;\n        else if (type === PBF_FIXED64) this.pos += 8;\n        else throw new Error(`Unimplemented type: ${type}`);\n    }\n\n    // === WRITING =================================================================\n\n    /**\n     * @param {number} tag\n     * @param {number} type\n     */\n    writeTag(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    }\n\n    /** @param {number} min */\n    realloc(min) {\n        let length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            const buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.dataView = new DataView(buf.buffer);\n            this.length = length;\n        }\n    }\n\n    finish() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    }\n\n    /** @param {number} val */\n    writeFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeSFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeSFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeVarint(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    }\n\n    /** @param {number} val */\n    writeSVarint(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    }\n\n    /** @param {boolean} val */\n    writeBoolean(val) {\n        this.writeVarint(+val);\n    }\n\n    /** @param {string} str */\n    writeString(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        const startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /** @param {number} val */\n    writeFloat(val) {\n        this.realloc(4);\n        this.dataView.setFloat32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeDouble(val) {\n        this.realloc(8);\n        this.dataView.setFloat64(this.pos, val, true);\n        this.pos += 8;\n    }\n\n    /** @param {Uint8Array} buffer */\n    writeBytes(buffer) {\n        const len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (let i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    }\n\n    /**\n     * @template T\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeRawMessage(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        const startPos = this.pos;\n        fn(obj, this);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /**\n     * @template T\n     * @param {number} tag\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeMessage(tag, fn, obj) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeRawMessage(fn, obj);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean[]} arr\n     */\n    writePackedBoolean(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFloat(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedDouble(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {Uint8Array} buffer\n     */\n    writeBytesField(tag, buffer) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeBytes(buffer);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeSFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeSFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeSVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {string} str\n     */\n    writeStringField(tag, str) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeString(str);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFloatField(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFloat(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeDoubleField(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeDouble(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean} val\n     */\n    writeBooleanField(tag, val) {\n        this.writeVarintField(tag, +val);\n    }\n};\n\n/**\n * @param {number} l\n * @param {boolean | undefined} s\n * @param {Pbf} p\n */\nfunction readVarintRemainder(l, s, p) {\n    const buf = p.buf;\n    let h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {boolean} [isSigned]\n */\nfunction toNum(low, high, isSigned) {\n    return isSigned ? high * 0x100000000 + (low >>> 0) : ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\n/**\n * @param {number} val\n * @param {Pbf} pbf\n */\nfunction writeBigVarint(val, pbf) {\n    let low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\n/**\n * @param {number} high\n * @param {number} low\n * @param {Pbf} pbf\n */\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\n/**\n * @param {number} high\n * @param {Pbf} pbf\n */\nfunction writeBigVarintHigh(high, pbf) {\n    const lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\n/**\n * @param {number} startPos\n * @param {number} len\n * @param {Pbf} pbf\n */\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    const extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (let i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFloat(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedDouble(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);\n}\n/**\n * @param {boolean[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedBoolean(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);\n}\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\n/**\n * @param {Uint8Array} buf\n * @param {number} pos\n * @param {number} end\n */\nfunction readUtf8(buf, pos, end) {\n    let str = '';\n    let i = pos;\n\n    while (i < end) {\n        const b0 = buf[i];\n        let c = null; // codepoint\n        let bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        let b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {string} str\n * @param {number} pos\n */\nfunction writeUtf8(buf, str, pos) {\n    for (let i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","/**\n * Pure canvas rendering logic for tile textures\n * Works with both HTMLCanvasElement (main thread) and OffscreenCanvas (worker)\n */\n\nimport type { TileBounds, ParsedFeature } from './types.js';\n\n/**\n * Road style configuration\n */\ninterface RoadStyle {\n  color: number;\n  width: number;\n}\n\n/**\n * Canvas type that works in both contexts\n */\ntype AnyCanvas = HTMLCanvasElement | OffscreenCanvas;\ntype AnyContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n/**\n * Colors for different feature types\n */\nconst COLORS: Record<string, number> = {\n  // Water types - blue tones\n  ocean: 0x1e5f8a,\n  sea: 0x1e5f8a,\n  lake: 0x2a7ab0,\n  reservoir: 0x2a7ab0,\n  pond: 0x3388bb,\n  river: 0x2a7ab0,\n  stream: 0x3388bb,\n  canal: 0x2a7ab0,\n  water: 0x1e5f8a,\n\n  // Bathymetry\n  bathymetry: 0x1e5f8a,\n\n  // Land cover types\n  forest: 0x1a4d2e,\n  wood: 0x1e5530,\n  grass: 0x5a8f4a,\n  shrub: 0x3a7a38,\n  crop: 0x8fa858,\n  barren: 0xa08060,\n  wetland: 0x3a6848,\n  swamp: 0x3a6848,\n  mangrove: 0x2a5040,\n  moss: 0x6a8a50,\n  snow: 0xe8f0f8,\n  urban: 0x6a6a6a,\n\n  // Additional land cover\n  park: 0x4a8050,\n  meadow: 0x5a8f4a,\n  farmland: 0x8fa858,\n\n  // Urban/developed (land_use)\n  residential: 0x707070,\n  commercial: 0x787878,\n  industrial: 0x606060,\n\n  // Default land - greenish-gray that blends with forest/grass areas\n  land: 0x8fa880,\n  default: 0x8fa880,\n};\n\n/**\n * Road styles\n */\nconst ROAD_STYLES: Record<string, RoadStyle> = {\n  motorway: { color: 0xa8a090, width: 3.0 },\n  trunk: { color: 0x9a9488, width: 2.5 },\n  primary: { color: 0x8c8880, width: 2.0 },\n  secondary: { color: 0x7e7a74, width: 1.5 },\n  tertiary: { color: 0x706c68, width: 1.2 },\n  residential: { color: 0x666666, width: 0.8 },\n  unclassified: { color: 0x555555, width: 0.6 },\n  service: { color: 0x444444, width: 0.4 },\n  living_street: { color: 0x555555, width: 0.6 },\n  pedestrian: { color: 0x888888, width: 0.5 },\n  footway: { color: 0x777777, width: 0.3 },\n  path: { color: 0x666666, width: 0.3 },\n  cycleway: { color: 0x5a8a5a, width: 0.4 },\n  rail: { color: 0x333333, width: 1.0 },\n  subway: { color: 0x333333, width: 0.8 },\n  tram: { color: 0x333333, width: 0.6 },\n  default: { color: 0x555555, width: 0.5 },\n};\n\n/**\n * Bathymetry depth color stops\n */\nconst BATHYMETRY_COLORS = [\n  { depth: 0, color: { r: 0x4a, g: 0xb0, b: 0xd0 } },\n  { depth: 200, color: { r: 0x3a, g: 0x9a, b: 0xc0 } },\n  { depth: 1000, color: { r: 0x2a, g: 0x80, b: 0xb0 } },\n  { depth: 2000, color: { r: 0x1e, g: 0x5f, b: 0x8a } },\n  { depth: 4000, color: { r: 0x15, g: 0x45, b: 0x70 } },\n  { depth: 6000, color: { r: 0x0d, g: 0x30, b: 0x55 } },\n  { depth: 10000, color: { r: 0x08, g: 0x20, b: 0x40 } },\n];\n\n/**\n * Linear water types to render as lines (not polygons)\n */\nconst LINEAR_WATER_TYPES = ['river', 'stream', 'canal', 'drain', 'ditch', 'waterway'];\n\n/**\n * Ocean/sea subtypes that indicate coastal water\n */\nconst OCEAN_SUBTYPES = ['ocean', 'sea', 'bay', 'strait', 'gulf', 'sound', 'harbour', 'harbor'];\n\n/**\n * Road priority for layering (lower = drawn first/underneath)\n */\nconst ROAD_PRIORITY: Record<string, number> = {\n  service: 0,\n  path: 1,\n  footway: 2,\n  cycleway: 3,\n  pedestrian: 4,\n  unclassified: 5,\n  living_street: 6,\n  residential: 7,\n  tertiary: 8,\n  secondary: 9,\n  primary: 10,\n  trunk: 11,\n  motorway: 12,\n};\n\n/**\n * Convert hex color to CSS string\n */\nfunction hexToCSS(hex: number): string {\n  return '#' + hex.toString(16).padStart(6, '0');\n}\n\n/**\n * Get bathymetry color based on depth\n */\nfunction getBathymetryColor(depth: number): number {\n  const clampedDepth = Math.max(0, Math.min(depth, 10000));\n\n  let lowerStop = BATHYMETRY_COLORS[0];\n  let upperStop = BATHYMETRY_COLORS[BATHYMETRY_COLORS.length - 1];\n\n  for (let i = 0; i < BATHYMETRY_COLORS.length - 1; i++) {\n    if (clampedDepth >= BATHYMETRY_COLORS[i].depth && clampedDepth <= BATHYMETRY_COLORS[i + 1].depth) {\n      lowerStop = BATHYMETRY_COLORS[i];\n      upperStop = BATHYMETRY_COLORS[i + 1];\n      break;\n    }\n  }\n\n  const range = upperStop.depth - lowerStop.depth;\n  const t = range > 0 ? (clampedDepth - lowerStop.depth) / range : 0;\n\n  const r = Math.round(lowerStop.color.r + t * (upperStop.color.r - lowerStop.color.r));\n  const g = Math.round(lowerStop.color.g + t * (upperStop.color.g - lowerStop.color.g));\n  const b = Math.round(lowerStop.color.b + t * (upperStop.color.b - lowerStop.color.b));\n\n  return (r << 16) | (g << 8) | b;\n}\n\n/**\n * Get color for a feature based on layer and properties\n */\nfunction getColorForFeature(layer: string, properties: Record<string, unknown>): number {\n  const subtype = (\n    properties.subtype ||\n    properties.class ||\n    properties.type ||\n    properties.category ||\n    ''\n  ) as string;\n  const type = subtype.toLowerCase();\n\n  if (layer === 'bathymetry') {\n    const depth = typeof properties.depth === 'number' ? properties.depth : 0;\n    return getBathymetryColor(depth);\n  }\n\n  if (layer === 'land_cover') {\n    return COLORS[type] ?? COLORS.grass;\n  }\n\n  if (COLORS[type]) {\n    return COLORS[type];\n  }\n\n  if (layer === 'water') {\n    return COLORS.water;\n  }\n\n  if (layer === 'land') {\n    return COLORS.land;\n  }\n\n  if (layer === 'land_use') {\n    if (type.includes('forest') || type.includes('wood')) return COLORS.forest;\n    if (type.includes('park') || type.includes('recreation')) return COLORS.park;\n    if (type.includes('grass') || type.includes('green') || type.includes('meadow')) return COLORS.grass;\n    if (type.includes('farm') || type.includes('orchard') || type.includes('vineyard')) return COLORS.crop;\n    if (type.includes('water') || type.includes('basin')) return COLORS.water;\n    if (type.includes('residential')) return COLORS.residential;\n    if (type.includes('commercial') || type.includes('retail')) return COLORS.commercial;\n    if (type.includes('industrial')) return COLORS.industrial;\n    if (type.includes('cemetery') || type.includes('grave')) return COLORS.grass;\n    return COLORS.land;\n  }\n\n  return COLORS.default;\n}\n\n/**\n * Get road style based on feature properties\n */\nfunction getRoadStyle(properties: Record<string, unknown> | null): RoadStyle {\n  if (!properties) return ROAD_STYLES.default;\n\n  const roadClass = (properties.class || properties.road_class || properties.highway || '') as string;\n  const type = roadClass.toLowerCase();\n\n  return ROAD_STYLES[type] ?? ROAD_STYLES.default;\n}\n\n/**\n * Create coordinate transform function for tile bounds\n */\nfunction createGeoToCanvas(bounds: TileBounds, size: number): (lng: number, lat: number) => { x: number; y: number } {\n  const lngRange = bounds.east - bounds.west;\n  const latRange = bounds.north - bounds.south;\n\n  return (lng: number, lat: number) => ({\n    x: ((lng - bounds.west) / lngRange) * size,\n    y: ((bounds.north - lat) / latRange) * size,\n  });\n}\n\n/**\n * Draw a single polygon with holes\n */\nfunction drawSinglePolygon(\n  ctx: AnyContext,\n  coords: number[][][],\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (!coords || coords.length === 0) return;\n\n  ctx.beginPath();\n\n  // Outer ring\n  const outer = coords[0];\n  if (!outer || outer.length === 0) return;\n\n  const start = geoToCanvas(outer[0][0], outer[0][1]);\n  ctx.moveTo(start.x, start.y);\n\n  for (let i = 1; i < outer.length; i++) {\n    const pt = geoToCanvas(outer[i][0], outer[i][1]);\n    ctx.lineTo(pt.x, pt.y);\n  }\n  ctx.closePath();\n\n  // Holes (inner rings) - use evenodd fill rule\n  for (let h = 1; h < coords.length; h++) {\n    const hole = coords[h];\n    if (!hole || hole.length === 0) continue;\n\n    const holeStart = geoToCanvas(hole[0][0], hole[0][1]);\n    ctx.moveTo(holeStart.x, holeStart.y);\n\n    for (let i = 1; i < hole.length; i++) {\n      const pt = geoToCanvas(hole[i][0], hole[i][1]);\n      ctx.lineTo(pt.x, pt.y);\n    }\n    ctx.closePath();\n  }\n}\n\n/**\n * Draw a polygon (with holes) on canvas\n */\nfunction drawPolygon(\n  ctx: AnyContext,\n  coordinates: number[][][] | number[][][][],\n  featureType: string,\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (featureType === 'Polygon') {\n    drawSinglePolygon(ctx, coordinates as number[][][], geoToCanvas);\n  } else if (featureType === 'MultiPolygon') {\n    for (const polygon of coordinates as number[][][][]) {\n      drawSinglePolygon(ctx, polygon, geoToCanvas);\n    }\n  }\n}\n\n/**\n * Draw a single line\n */\nfunction drawSingleLine(\n  ctx: AnyContext,\n  coords: number[][],\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (!coords || coords.length < 2) return;\n\n  ctx.beginPath();\n  const start = geoToCanvas(coords[0][0], coords[0][1]);\n  ctx.moveTo(start.x, start.y);\n\n  for (let i = 1; i < coords.length; i++) {\n    const pt = geoToCanvas(coords[i][0], coords[i][1]);\n    ctx.lineTo(pt.x, pt.y);\n  }\n\n  ctx.stroke();\n}\n\n/**\n * Draw a line string on canvas\n */\nfunction drawLineString(\n  ctx: AnyContext,\n  coordinates: number[][] | number[][][],\n  featureType: string,\n  geoToCanvas: (lng: number, lat: number) => { x: number; y: number }\n): void {\n  if (featureType === 'LineString') {\n    drawSingleLine(ctx, coordinates as number[][], geoToCanvas);\n  } else if (featureType === 'MultiLineString') {\n    for (const line of coordinates as number[][][]) {\n      drawSingleLine(ctx, line, geoToCanvas);\n    }\n  }\n}\n\n/**\n * Render all features for a tile to a canvas\n * Works with both HTMLCanvasElement and OffscreenCanvas\n */\nexport function renderTileTextureToCanvas(\n  canvas: AnyCanvas,\n  baseFeatures: ParsedFeature[],\n  transportFeatures: ParsedFeature[],\n  bounds: TileBounds\n): void {\n  const size = canvas.width;\n  const ctx = canvas.getContext('2d') as AnyContext;\n  if (!ctx) return;\n\n  // Enable antialiasing\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n\n  const geoToCanvas = createGeoToCanvas(bounds, size);\n\n  // Calculate meters per pixel for road width scaling\n  const tileSizeMeters = (bounds.east - bounds.west) * 111320 * Math.cos(((bounds.north + bounds.south) / 2) * Math.PI / 180);\n  const metersPerPixel = tileSizeMeters / size;\n\n  // Separate features by layer first to determine base color\n  const landFeatures: ParsedFeature[] = [];\n  const landUseFeatures: ParsedFeature[] = [];\n  const landCoverFeatures: ParsedFeature[] = [];\n  const waterLineFeatures: ParsedFeature[] = [];\n  const waterBodyFeatures: ParsedFeature[] = [];\n  const oceanFeatures: ParsedFeature[] = [];\n\n  for (const feature of baseFeatures) {\n    const layer = feature.layer;\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n\n    if (layer === 'land') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        landFeatures.push(feature);\n      }\n    } else if (layer === 'land_use') {\n      landUseFeatures.push(feature);\n    } else if (layer === 'land_cover') {\n      landCoverFeatures.push(feature);\n    } else if (layer === 'water') {\n      if (feature.type === 'LineString' || feature.type === 'MultiLineString') {\n        if (LINEAR_WATER_TYPES.includes(subtype)) {\n          waterLineFeatures.push(feature);\n        }\n      } else if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        const isFromLowerZoom = feature.properties._fromLowerZoom === true;\n        if (OCEAN_SUBTYPES.includes(subtype) || isFromLowerZoom) {\n          oceanFeatures.push(feature);\n        } else {\n          waterBodyFeatures.push(feature);\n        }\n      }\n    }\n  }\n\n  // Detect if this is an open ocean tile\n  const isOpenOceanTile = oceanFeatures.length > 0 && landFeatures.length < 10;\n\n  // === Layer 0: Base fill ===\n  if (isOpenOceanTile) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    ctx.fillRect(0, 0, size, size);\n  } else {\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    ctx.fillRect(0, 0, size, size);\n  }\n\n  // === Layer 1: Land polygons (for open ocean tiles) ===\n  if (isOpenOceanTile && landFeatures.length > 0) {\n    ctx.save();\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    for (const feature of landFeatures) {\n      drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n      ctx.fill('evenodd');\n    }\n    ctx.restore();\n  }\n\n  // === Layer 2: Land use ===\n  ctx.save();\n  for (const feature of landUseFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_use', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 3: Land cover ===\n  ctx.save();\n  for (const feature of landCoverFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_cover', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 4: Water lines (rivers/streams) ===\n  // Render with wider strokes since river polygons often don't exist at lower zoom levels\n  ctx.save();\n  ctx.strokeStyle = hexToCSS(COLORS.river);\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  for (const feature of waterLineFeatures) {\n    // Use subtype to determine line width: rivers are wider than streams\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n    let widthMeters = 8; // Default river width\n    if (subtype === 'stream' || subtype === 'drain' || subtype === 'ditch') {\n      widthMeters = 3;\n    } else if (subtype === 'canal') {\n      widthMeters = 12;\n    } else if (subtype === 'river') {\n      widthMeters = 20; // Major rivers\n    }\n    ctx.lineWidth = Math.max(2, widthMeters / metersPerPixel);\n    drawLineString(ctx, feature.coordinates as number[][] | number[][][], feature.type, geoToCanvas);\n  }\n  ctx.restore();\n\n  // === Layer 5: Water bodies (ocean + inland) ===\n  ctx.save();\n  for (const feature of oceanFeatures) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  for (const feature of waterBodyFeatures) {\n    const color = getColorForFeature('water', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 6: Roads ===\n  const roadFeatures = transportFeatures\n    .filter(f => {\n      if (f.layer === 'connector') return false;\n      if (f.layer !== 'segment') return false;\n      if (f.type !== 'LineString' && f.type !== 'MultiLineString') return false;\n      if (f.properties?.subtype !== 'road') return false;\n\n      const props = f.properties as Record<string, unknown>;\n\n      // Check road_flags for is_tunnel\n      if (typeof props.road_flags === 'string') {\n        try {\n          const flags = JSON.parse(props.road_flags) as Array<{ values?: string[] }>;\n          const hasTunnel = flags.some(flag => flag.values?.includes('is_tunnel'));\n          if (hasTunnel) return false;\n        } catch {\n          // Ignore parse errors\n        }\n      }\n\n      // Check level_rules for negative levels\n      if (typeof props.level_rules === 'string') {\n        try {\n          const rules = JSON.parse(props.level_rules) as Array<{ value?: number }>;\n          const hasNegativeLevel = rules.length > 0 && rules.every(rule =>\n            typeof rule.value === 'number' && rule.value < 0\n          );\n          if (hasNegativeLevel) return false;\n        } catch {\n          // Ignore parse errors\n        }\n      }\n\n      if (props.is_tunnel === true || props.is_underground === true) return false;\n      if (typeof props.level === 'number' && props.level < 0) return false;\n\n      return true;\n    })\n    .sort((a, b) => {\n      const classA = ((a.properties?.class || 'default') as string).toLowerCase();\n      const classB = ((b.properties?.class || 'default') as string).toLowerCase();\n      return (ROAD_PRIORITY[classA] ?? 5) - (ROAD_PRIORITY[classB] ?? 5);\n    });\n\n  ctx.save();\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n\n  for (const feature of roadFeatures) {\n    const style = getRoadStyle(feature.properties);\n    const widthPixels = Math.max(1, (style.width * 5) / metersPerPixel);\n\n    ctx.strokeStyle = hexToCSS(style.color);\n    ctx.lineWidth = widthPixels;\n    drawLineString(ctx, feature.coordinates as number[][] | number[][][], feature.type, geoToCanvas);\n  }\n  ctx.restore();\n}\n\n/**\n * Render simplified features for a low-detail distant tile\n * Works with both HTMLCanvasElement and OffscreenCanvas\n */\nexport function renderLowDetailTextureToCanvas(\n  canvas: AnyCanvas,\n  baseFeatures: ParsedFeature[],\n  bounds: TileBounds\n): void {\n  const size = canvas.width;\n  const ctx = canvas.getContext('2d') as AnyContext;\n  if (!ctx) return;\n\n  // Enable antialiasing\n  ctx.imageSmoothingEnabled = true;\n  ctx.imageSmoothingQuality = 'high';\n\n  const geoToCanvas = createGeoToCanvas(bounds, size);\n\n  // Separate features by layer\n  const landFeatures: ParsedFeature[] = [];\n  const landCoverFeatures: ParsedFeature[] = [];\n  const waterBodyFeatures: ParsedFeature[] = [];\n  const oceanFeatures: ParsedFeature[] = [];\n\n  for (const feature of baseFeatures) {\n    const layer = feature.layer;\n    const subtype = ((feature.properties.subtype || feature.properties.class || '') as string).toLowerCase();\n\n    if (layer === 'land') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        landFeatures.push(feature);\n      }\n    } else if (layer === 'land_cover') {\n      landCoverFeatures.push(feature);\n    } else if (layer === 'water') {\n      if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n        const isFromLowerZoom = feature.properties._fromLowerZoom === true;\n        if (OCEAN_SUBTYPES.includes(subtype) || isFromLowerZoom) {\n          oceanFeatures.push(feature);\n        } else {\n          waterBodyFeatures.push(feature);\n        }\n      }\n    }\n  }\n\n  // Detect if this is an open ocean tile\n  const isOpenOceanTile = oceanFeatures.length > 0 && landFeatures.length < 10;\n\n  // === Layer 0: Base fill ===\n  if (isOpenOceanTile) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    ctx.fillRect(0, 0, size, size);\n  } else {\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    ctx.fillRect(0, 0, size, size);\n  }\n\n  // === Layer 1: Land polygons (for open ocean tiles) ===\n  if (isOpenOceanTile && landFeatures.length > 0) {\n    ctx.save();\n    ctx.fillStyle = hexToCSS(COLORS.land);\n    for (const feature of landFeatures) {\n      drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n      ctx.fill('evenodd');\n    }\n    ctx.restore();\n  }\n\n  // === Layer 2: Land cover ===\n  ctx.save();\n  for (const feature of landCoverFeatures) {\n    if (feature.type !== 'Polygon' && feature.type !== 'MultiPolygon') continue;\n\n    const color = getColorForFeature('land_cover', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n\n  // === Layer 3: Water bodies ===\n  ctx.save();\n  for (const feature of oceanFeatures) {\n    ctx.fillStyle = hexToCSS(COLORS.water);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  for (const feature of waterBodyFeatures) {\n    const color = getColorForFeature('water', feature.properties);\n    ctx.fillStyle = hexToCSS(color);\n    drawPolygon(ctx, feature.coordinates as number[][][] | number[][][][], feature.type, geoToCanvas);\n    ctx.fill('evenodd');\n  }\n  ctx.restore();\n}\n","/**\n * Full-pipeline texture worker\n * Handles fetch -> parse -> render entirely in worker to avoid structured clone overhead\n *\n * Benefits:\n * - No structured clone for feature arrays (they never leave the worker)\n * - Only ImageBitmap transferred back (zero-copy)\n * - PMTiles fetch happens in worker thread (no main thread blocking)\n * - Loads lower-zoom water (z10) and land_cover (z12) for background coverage\n */\n\nimport { PMTiles } from 'pmtiles';\nimport { VectorTile } from '@mapbox/vector-tile';\nimport Pbf from 'pbf';\nimport type { WorkerResponse, TileBounds, ParsedFeature } from './types.js';\nimport { renderTileTextureToCanvas } from './offscreen-renderer.js';\n\n// PMTiles sources (lazy initialized)\nlet basePMTiles: PMTiles | null = null;\nlet transportationPMTiles: PMTiles | null = null;\nlet pmtilesInitialized = false;\nlet pmtilesInitPromise: Promise<void> | null = null;\n\n// Cached PMTiles URLs for initialization\nlet basePMTilesUrl: string | null = null;\nlet transportationPMTilesUrl: string | null = null;\n\n// Test OffscreenCanvas capability\nlet offscreenCanvasSupported = false;\ntry {\n  const testCanvas = new OffscreenCanvas(1, 1);\n  const testCtx = testCanvas.getContext('2d');\n  offscreenCanvasSupported = testCtx !== null;\n} catch {\n  offscreenCanvasSupported = false;\n}\n\n/**\n * Request types for full pipeline worker\n */\ninterface FullPipelineRequest {\n  type: 'RENDER_FULL_PIPELINE';\n  id: string;\n  payload: {\n    tileX: number;\n    tileY: number;\n    tileZ: number;\n    textureSize: number;\n    basePMTilesUrl: string;\n    transportationPMTilesUrl: string;\n    includeNeighbors: boolean;\n    includeTransportation: boolean;\n  };\n}\n\ninterface InitRequest {\n  type: 'INIT_PMTILES';\n  id: string;\n  payload: {\n    basePMTilesUrl: string;\n    transportationPMTilesUrl: string;\n  };\n}\n\ninterface CapabilityRequest {\n  type: 'CAPABILITY_CHECK';\n  id: string;\n}\n\ntype WorkerRequest = FullPipelineRequest | InitRequest | CapabilityRequest;\n\n/**\n * Initialize PMTiles sources (called once, lazy)\n */\nasync function initializePMTiles(baseUrl: string, transportUrl: string): Promise<void> {\n  // Already initialized with matching URLs\n  if (pmtilesInitialized && basePMTilesUrl === baseUrl && transportationPMTilesUrl === transportUrl) {\n    return;\n  }\n\n  // If there's a pending init, check if URLs match before awaiting\n  if (pmtilesInitPromise) {\n    // URLs changed during pending init - wait for current to finish, then re-init\n    if (basePMTilesUrl !== baseUrl || transportationPMTilesUrl !== transportUrl) {\n      await pmtilesInitPromise;\n      // Reset and fall through to re-initialize with new URLs\n      pmtilesInitialized = false;\n    } else {\n      await pmtilesInitPromise;\n      return;\n    }\n  }\n\n  pmtilesInitPromise = (async () => {\n    try {\n      basePMTilesUrl = baseUrl;\n      transportationPMTilesUrl = transportUrl;\n\n      basePMTiles = new PMTiles(baseUrl);\n      transportationPMTiles = new PMTiles(transportUrl);\n\n      // Verify headers are accessible (validates CORS)\n      await Promise.all([\n        basePMTiles.getHeader(),\n        transportationPMTiles.getHeader(),\n      ]);\n\n      pmtilesInitialized = true;\n    } catch (error) {\n      console.error('[FullPipelineWorker] Failed to initialize PMTiles:', error);\n      basePMTiles = null;\n      transportationPMTiles = null;\n      basePMTilesUrl = null;\n      transportationPMTilesUrl = null;\n      pmtilesInitialized = false;\n      throw error;\n    }\n  })();\n\n  try {\n    await pmtilesInitPromise;\n  } finally {\n    // Always clear promise to allow retries after transient failures\n    pmtilesInitPromise = null;\n  }\n}\n\n/**\n * Calculate tile bounds from tile coordinates\n */\nfunction tileToBounds(x: number, y: number, z: number): TileBounds {\n  const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);\n  const north = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n\n  const n2 = Math.PI - (2 * Math.PI * (y + 1)) / Math.pow(2, z);\n  const south = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));\n\n  const west = (x / Math.pow(2, z)) * 360 - 180;\n  const east = ((x + 1) / Math.pow(2, z)) * 360 - 180;\n\n  return { north, south, west, east };\n}\n\n/**\n * Parse MVT data to features\n */\nfunction parseMVT(\n  data: ArrayBuffer,\n  tileX: number,\n  tileY: number,\n  zoom: number,\n  layerName: string | null = null\n): ParsedFeature[] {\n  const tile = new VectorTile(new Pbf(data));\n  const features: ParsedFeature[] = [];\n\n  const allLayerNames = Object.keys(tile.layers);\n  const layerNames = layerName && tile.layers[layerName] ? [layerName] : allLayerNames;\n\n  for (const name of layerNames) {\n    const layer = tile.layers[name];\n    if (!layer) continue;\n\n    for (let i = 0; i < layer.length; i++) {\n      const feature = layer.feature(i);\n      const geojson = feature.toGeoJSON(tileX, tileY, zoom);\n\n      features.push({\n        type: geojson.geometry.type,\n        coordinates: geojson.geometry.coordinates,\n        properties: feature.properties as Record<string, unknown>,\n        layer: name,\n      });\n    }\n  }\n\n  return features;\n}\n\n/**\n * Fetch tile data from PMTiles\n */\nasync function fetchTileData(\n  pmtiles: PMTiles,\n  z: number,\n  x: number,\n  y: number\n): Promise<ArrayBuffer | null> {\n  try {\n    const result = await pmtiles.getZxy(z, x, y);\n    return result?.data ?? null;\n  } catch (error) {\n    console.warn(`[FullPipelineWorker] Failed to fetch tile ${z}/${x}/${y}:`, error);\n    return null;\n  }\n}\n\n// Lower zoom levels to check for water polygons (highest detail first)\n// Include more zoom levels to catch river polygons that may only exist at certain zooms\nconst WATER_POLYGON_ZOOM_LEVELS = [13, 12, 11, 10, 8, 6];\n\n// Stop loading lower zoom water once we have this many polygons intersecting the tile\n// This prevents loading overly simplified z6 data when we already have good coverage\nconst WATER_POLYGON_SUFFICIENT_COUNT = 5;\n\n/**\n * Load water polygons from lower zoom levels for ocean coverage\n * Loads water from higher detail levels first, bailing out early once sufficient coverage is found.\n * This prevents loading overly simplified z6 data when we already have good river/lake coverage.\n */\nasync function loadLowerZoomWater(\n  tileX: number,\n  tileY: number,\n  tileZ: number\n): Promise<ParsedFeature[]> {\n  if (!basePMTiles) return [];\n\n  const waterPolygons: ParsedFeature[] = [];\n  const seenAreas = new Set<string>(); // Track polygons to avoid duplicates\n\n  for (const lowerZoom of WATER_POLYGON_ZOOM_LEVELS) {\n    if (lowerZoom >= tileZ) continue; // Only check lower (zoomed out) levels\n\n    // Calculate which lower-zoom tile contains this tile\n    const scale = Math.pow(2, tileZ - lowerZoom);\n    const lowerX = Math.floor(tileX / scale);\n    const lowerY = Math.floor(tileY / scale);\n\n    const data = await fetchTileData(basePMTiles, lowerZoom, lowerX, lowerY);\n    if (!data) continue;\n\n    // Only extract water layer polygons\n    const allFeatures = parseMVT(data, lowerX, lowerY, lowerZoom);\n\n    const waterFeatures = allFeatures.filter(f =>\n      f.layer === 'water' &&\n      (f.type === 'Polygon' || f.type === 'MultiPolygon')\n    );\n\n    // Dedupe across zoom levels using first coordinate as key\n    for (const feature of waterFeatures) {\n      const coords = feature.coordinates as number[][][] | number[][][][];\n      const firstRing = feature.type === 'Polygon' ? coords[0] : (coords[0] as number[][][])[0];\n      if (!firstRing || firstRing.length < 3) continue;\n\n      const firstCoord = firstRing[0] as number[];\n      const areaKey = `${firstCoord[0].toFixed(4)},${firstCoord[1].toFixed(4)}`;\n\n      if (seenAreas.has(areaKey)) continue;\n      seenAreas.add(areaKey);\n\n      // Mark as coming from lower zoom\n      feature.properties = {\n        ...feature.properties,\n        _fromLowerZoom: true,\n        _sourceZoom: lowerZoom\n      };\n      waterPolygons.push(feature);\n    }\n\n    // Bail out early if we have sufficient water polygon coverage\n    // This prevents loading overly simplified z6/z8 data when higher zoom data is available\n    if (waterPolygons.length >= WATER_POLYGON_SUFFICIENT_COUNT) {\n      break;\n    }\n  }\n\n  return waterPolygons;\n}\n\n/**\n * Load base features for a tile (and optionally neighbors)\n * Also loads lower-zoom water and land_cover for background coverage\n */\nasync function loadBaseFeatures(\n  tileX: number,\n  tileY: number,\n  tileZ: number,\n  includeNeighbors: boolean\n): Promise<ParsedFeature[]> {\n  if (!basePMTiles) return [];\n\n  // Start all fetches in parallel\n  const promises: Promise<ParsedFeature[]>[] = [];\n\n  // 1. Load lower-zoom water for ocean coverage (loads z10, z8, z6 and merges results)\n  promises.push(loadLowerZoomWater(tileX, tileY, tileZ));\n\n  // 2. Load lower-zoom base features for land_cover background (z12)\n  const lowerZoom = Math.max(10, tileZ - 2);\n  const scale = Math.pow(2, tileZ - lowerZoom);\n  const lowerX = Math.floor(tileX / scale);\n  const lowerY = Math.floor(tileY / scale);\n  promises.push(\n    fetchTileData(basePMTiles, lowerZoom, lowerX, lowerY).then(data => {\n      if (!data) return [];\n      return parseMVT(data, lowerX, lowerY, lowerZoom);\n    })\n  );\n\n  // 3. Load center tile\n  promises.push(\n    fetchTileData(basePMTiles, tileZ, tileX, tileY).then(data => {\n      if (!data) return [];\n      return parseMVT(data, tileX, tileY, tileZ);\n    })\n  );\n\n  // 4. Load neighbor tiles if requested\n  if (includeNeighbors) {\n    for (let dx = -1; dx <= 1; dx++) {\n      for (let dy = -1; dy <= 1; dy++) {\n        if (dx === 0 && dy === 0) continue; // Skip center\n\n        const nx = tileX + dx;\n        const ny = tileY + dy;\n\n        promises.push(\n          fetchTileData(basePMTiles!, tileZ, nx, ny).then(data => {\n            if (!data) return [];\n            return parseMVT(data, nx, ny, tileZ);\n          })\n        );\n      }\n    }\n  }\n\n  // Wait for all fetches and merge in order (lower zoom first for background)\n  const results = await Promise.all(promises);\n\n  // Merge: lower zoom water -> lower zoom base -> center tile -> neighbors\n  const features: ParsedFeature[] = [];\n  for (const result of results) {\n    features.push(...result);\n  }\n\n  return features;\n}\n\n/**\n * Load transportation features for a tile\n */\nasync function loadTransportationFeatures(\n  tileX: number,\n  tileY: number,\n  tileZ: number\n): Promise<ParsedFeature[]> {\n  if (!transportationPMTiles) return [];\n\n  const data = await fetchTileData(transportationPMTiles, tileZ, tileX, tileY);\n  if (!data) return [];\n\n  return parseMVT(data, tileX, tileY, tileZ);\n}\n\n/**\n * Render full tile pipeline\n */\nasync function renderFullPipeline(\n  tileX: number,\n  tileY: number,\n  tileZ: number,\n  textureSize: number,\n  basePMTilesUrl: string,\n  transportationPMTilesUrl: string,\n  includeNeighbors: boolean,\n  includeTransportation: boolean\n): Promise<ImageBitmap> {\n  // Initialize PMTiles if needed\n  await initializePMTiles(basePMTilesUrl, transportationPMTilesUrl);\n\n  // Calculate bounds\n  const bounds = tileToBounds(tileX, tileY, tileZ);\n\n  // Fetch and parse features in parallel\n  const [baseFeatures, transportFeatures] = await Promise.all([\n    loadBaseFeatures(tileX, tileY, tileZ, includeNeighbors),\n    includeTransportation ? loadTransportationFeatures(tileX, tileY, tileZ) : Promise.resolve([]),\n  ]);\n\n  // Create OffscreenCanvas and render\n  const canvas = new OffscreenCanvas(textureSize, textureSize);\n  renderTileTextureToCanvas(canvas, baseFeatures, transportFeatures, bounds);\n\n  // Transfer ImageBitmap back (zero-copy)\n  return canvas.transferToImageBitmap();\n}\n\n/**\n * Handle incoming messages\n */\nself.onmessage = async (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case 'CAPABILITY_CHECK': {\n        const response: WorkerResponse = {\n          type: 'CAPABILITY_CHECK_RESULT',\n          id: request.id,\n          supported: offscreenCanvasSupported,\n        };\n        self.postMessage(response);\n        break;\n      }\n\n      case 'INIT_PMTILES': {\n        const { basePMTilesUrl, transportationPMTilesUrl } = request.payload;\n        await initializePMTiles(basePMTilesUrl, transportationPMTilesUrl);\n\n        const response: WorkerResponse = {\n          type: 'CAPABILITY_CHECK_RESULT',\n          id: request.id,\n          supported: true,\n        };\n        self.postMessage(response);\n        break;\n      }\n\n      case 'RENDER_FULL_PIPELINE': {\n        if (!offscreenCanvasSupported) {\n          const response: WorkerResponse = {\n            type: 'ERROR',\n            id: request.id,\n            error: 'OffscreenCanvas not supported',\n          };\n          self.postMessage(response);\n          return;\n        }\n\n        const {\n          tileX,\n          tileY,\n          tileZ,\n          textureSize,\n          basePMTilesUrl,\n          transportationPMTilesUrl,\n          includeNeighbors,\n          includeTransportation,\n        } = request.payload;\n\n        const bitmap = await renderFullPipeline(\n          tileX,\n          tileY,\n          tileZ,\n          textureSize,\n          basePMTilesUrl,\n          transportationPMTilesUrl,\n          includeNeighbors,\n          includeTransportation\n        );\n\n        const response: WorkerResponse = {\n          type: 'RENDER_TILE_TEXTURE_RESULT',\n          id: request.id,\n          result: bitmap,\n        };\n        self.postMessage(response, { transfer: [bitmap] });\n        break;\n      }\n\n      default: {\n        // Safe extraction of id and type from unknown request\n        const unknownRequest = request as Record<string, unknown>;\n        const requestId = typeof unknownRequest.id === 'string' ? unknownRequest.id : 'unknown';\n        const requestType = typeof unknownRequest.type === 'string' ? unknownRequest.type : 'undefined';\n\n        const response: WorkerResponse = {\n          type: 'ERROR',\n          id: requestId,\n          error: `Unknown request type: ${requestType}`,\n        };\n        self.postMessage(response);\n      }\n    }\n  } catch (error) {\n    const response: WorkerResponse = {\n      type: 'ERROR',\n      id: request.id,\n      error: error instanceof Error ? error.message : 'Unknown error in full-pipeline worker',\n    };\n    self.postMessage(response);\n  }\n};\n\n// Signal that worker is ready\nself.postMessage({ type: 'READY' });\n"],"names":["u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","r","j","_a","fl","revfl","_b","fd","rev","i","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","e","ec","err","ind","msg","nt","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","shift","dend","et","gzs","flg","zs","gzl","zls","inflateSync","data","opts","gunzipSync","unzlibSync","decompressSync","td","tds","B","u","h","W","E","y","w","z","f","N","k","q","G","ie","J","D","F","O","_","Y","Q","A","C","T","g","X","Z","U","I","K","R","M","P","H","Point","other","dx","dy","angle","cos","sin","VectorTileFeature","pbf","extent","keys","values","readFeature","lines","line","cmd","length","cmdLen","x1","x2","y1","y2","size","x0","y0","vtCoords","projectPoint","projectLine","geometry","points","coordinates","polygons","classifyRings","polygon","result","tag","feature","readTag","key","value","rings","len","ccw","area","signedArea","ring","sum","p1","p2","VectorTileLayer","readLayer","layer","readValueMessage","VectorTile","readTile","layers","SHIFT_LEFT_32","SHIFT_RIGHT_32","TEXT_DECODER_MIN_LENGTH","utf8TextDecoder","PBF_VARINT","PBF_FIXED64","PBF_BYTES","PBF_FIXED32","Pbf","readField","val","startPos","isSigned","readVarintRemainder","num","readUtf8","buffer","arr","min","writeBigVarint","str","writeUtf8","makeRoomForExtraLength","fn","obj","writePackedVarint","writePackedSVarint","writePackedBoolean","writePackedFloat","writePackedDouble","writePackedFixed32","writePackedSFixed32","writePackedFixed64","writePackedSFixed64","toNum","low","high","writeBigVarintLow","writeBigVarintHigh","lsb","extraLen","b0","bytesPerSequence","b1","b2","b3","lead","COLORS","ROAD_STYLES","BATHYMETRY_COLORS","LINEAR_WATER_TYPES","OCEAN_SUBTYPES","ROAD_PRIORITY","hexToCSS","hex","getBathymetryColor","depth","clampedDepth","lowerStop","upperStop","range","getColorForFeature","properties","getRoadStyle","createGeoToCanvas","bounds","lngRange","latRange","lng","lat","drawSinglePolygon","ctx","coords","geoToCanvas","outer","pt","hole","holeStart","drawPolygon","featureType","drawSingleLine","drawLineString","renderTileTextureToCanvas","canvas","baseFeatures","transportFeatures","metersPerPixel","landFeatures","landUseFeatures","landCoverFeatures","waterLineFeatures","waterBodyFeatures","oceanFeatures","subtype","isFromLowerZoom","isOpenOceanTile","color","widthMeters","roadFeatures","props","flag","rules","rule","classA","classB","style","widthPixels","basePMTiles","transportationPMTiles","pmtilesInitialized","pmtilesInitPromise","basePMTilesUrl","transportationPMTilesUrl","offscreenCanvasSupported","initializePMTiles","baseUrl","transportUrl","PMTiles","error","tileToBounds","north","n2","south","west","east","parseMVT","tileX","tileY","zoom","layerName","tile","features","allLayerNames","layerNames","name","geojson","fetchTileData","pmtiles","WATER_POLYGON_ZOOM_LEVELS","WATER_POLYGON_SUFFICIENT_COUNT","loadLowerZoomWater","tileZ","waterPolygons","seenAreas","lowerZoom","scale","lowerX","lowerY","waterFeatures","firstRing","firstCoord","areaKey","loadBaseFeatures","includeNeighbors","promises","nx","ny","results","loadTransportationFeatures","renderFullPipeline","textureSize","includeTransportation","event","request","response","bitmap","unknownRequest","requestId","requestType"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}