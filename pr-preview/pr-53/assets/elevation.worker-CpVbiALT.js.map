{"version":3,"file":"elevation.worker-CpVbiALT.js","sources":["../src/workers/elevation.worker.ts"],"sourcesContent":["/**\n * Web Worker for elevation tile decoding\n * Offloads CPU-intensive Terrarium PNG decoding from the main thread\n * Uses OffscreenCanvas for image processing in worker context\n */\n\nimport type { WorkerRequest, WorkerResponse, DecodeElevationResult } from './types.js';\n\n// Check if OffscreenCanvas is available\nconst hasOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';\n\n/**\n * Decode Terrarium RGB values to height in meters\n * Formula: height = (R * 256 + G + B/256) - 32768\n */\nfunction decodeTerrarium(r: number, g: number, b: number, offset: number): number {\n  return (r * 256 + g + b / 256) - offset;\n}\n\n/**\n * Fetch image as ImageBitmap (works in worker context)\n */\nasync function fetchImageBitmap(url: string): Promise<ImageBitmap> {\n  const response = await fetch(url, { mode: 'cors' });\n  if (!response.ok) {\n    throw new Error(`Failed to fetch image: ${response.status}`);\n  }\n  const blob = await response.blob();\n  return createImageBitmap(blob);\n}\n\n/**\n * Decode elevation tile from URL\n * Uses OffscreenCanvas to extract pixel data and convert to heights\n */\nasync function decodeElevationTile(\n  url: string,\n  tileSize: number,\n  terrariumOffset: number\n): Promise<DecodeElevationResult> {\n  // Fetch image as ImageBitmap\n  const bitmap = await fetchImageBitmap(url);\n\n  // Create OffscreenCanvas and draw image\n  const canvas = new OffscreenCanvas(tileSize, tileSize);\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Failed to get 2d context from OffscreenCanvas');\n  }\n\n  ctx.drawImage(bitmap, 0, 0, tileSize, tileSize);\n  bitmap.close(); // Free memory\n\n  // Extract pixel data\n  const imageData = ctx.getImageData(0, 0, tileSize, tileSize);\n  const heights = new Float32Array(tileSize * tileSize);\n\n  // Decode Terrarium RGB values to heights\n  for (let i = 0; i < tileSize * tileSize; i++) {\n    const r = imageData.data[i * 4];\n    const g = imageData.data[i * 4 + 1];\n    const b = imageData.data[i * 4 + 2];\n    heights[i] = decodeTerrarium(r, g, b, terrariumOffset);\n  }\n\n  return { heights };\n}\n\n/**\n * Handle incoming messages from the main thread\n */\nself.onmessage = async (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case 'CAPABILITY_CHECK': {\n        // Check if OffscreenCanvas is available\n        const response: WorkerResponse = {\n          type: 'CAPABILITY_CHECK_RESULT',\n          id: request.id,\n          supported: hasOffscreenCanvas,\n        };\n        self.postMessage(response);\n        break;\n      }\n\n      case 'DECODE_ELEVATION': {\n        if (!hasOffscreenCanvas) {\n          throw new Error('OffscreenCanvas not supported in this worker');\n        }\n\n        const { url, tileSize, terrariumOffset } = request.payload;\n\n        // Decode elevation tile\n        const result = await decodeElevationTile(url, tileSize, terrariumOffset);\n\n        // Transfer the heights buffer (zero-copy)\n        const response: WorkerResponse = {\n          type: 'DECODE_ELEVATION_RESULT',\n          id: request.id,\n          result,\n        };\n\n        self.postMessage(response, { transfer: [result.heights.buffer] });\n        break;\n      }\n\n      default: {\n        const response: WorkerResponse = {\n          type: 'ERROR',\n          id: (request as { id?: string }).id || 'unknown',\n          error: `Elevation worker received unsupported request type: ${(request as { type?: string }).type}`,\n        };\n        self.postMessage(response);\n      }\n    }\n  } catch (error) {\n    const response: WorkerResponse = {\n      type: 'ERROR',\n      id: request.id,\n      error: error instanceof Error ? error.message : 'Unknown error in elevation worker',\n    };\n    self.postMessage(response);\n  }\n};\n\n// Signal that worker is ready\nself.postMessage({ type: 'READY' });\n"],"names":["hasOffscreenCanvas","decodeTerrarium","g","b","offset","fetchImageBitmap","url","response","blob","decodeElevationTile","tileSize","terrariumOffset","bitmap","ctx","imageData","heights","i","r","event","request","result","error"],"mappings":"yBASA,MAAMA,EAAqB,OAAO,gBAAoB,IAMtD,SAASC,EAAgB,EAAWC,EAAWC,EAAWC,EAAwB,CAChF,OAAQ,EAAI,IAAMF,EAAIC,EAAI,IAAOC,CACnC,CAKA,eAAeC,EAAiBC,EAAmC,CACjE,MAAMC,EAAW,MAAM,MAAMD,EAAK,CAAE,KAAM,OAAQ,EAClD,GAAI,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,0BAA0BA,EAAS,MAAM,EAAE,EAE7D,MAAMC,EAAO,MAAMD,EAAS,KAAA,EAC5B,OAAO,kBAAkBC,CAAI,CAC/B,CAMA,eAAeC,EACbH,EACAI,EACAC,EACgC,CAEhC,MAAMC,EAAS,MAAMP,EAAiBC,CAAG,EAInCO,EADS,IAAI,gBAAgBH,EAAUA,CAAQ,EAClC,WAAW,IAAI,EAClC,GAAI,CAACG,EACH,MAAM,IAAI,MAAM,+CAA+C,EAGjEA,EAAI,UAAUD,EAAQ,EAAG,EAAGF,EAAUA,CAAQ,EAC9CE,EAAO,MAAA,EAGP,MAAME,EAAYD,EAAI,aAAa,EAAG,EAAGH,EAAUA,CAAQ,EACrDK,EAAU,IAAI,aAAaL,EAAWA,CAAQ,EAGpD,QAASM,EAAI,EAAGA,EAAIN,EAAWA,EAAUM,IAAK,CAC5C,MAAMC,EAAIH,EAAU,KAAKE,EAAI,CAAC,EACxB,EAAIF,EAAU,KAAKE,EAAI,EAAI,CAAC,EAC5Bb,EAAIW,EAAU,KAAKE,EAAI,EAAI,CAAC,EAClCD,EAAQC,CAAC,EAAIf,EAAgBgB,EAAG,EAAGd,EAAGQ,CAAe,CACvD,CAEA,MAAO,CAAE,QAAAI,CAAA,CACX,CAKA,KAAK,UAAY,MAAOG,GAAuC,CAC7D,MAAMC,EAAUD,EAAM,KAEtB,GAAI,CACF,OAAQC,EAAQ,KAAA,CACd,IAAK,mBAAoB,CAEvB,MAAMZ,EAA2B,CAC/B,KAAM,0BACN,GAAIY,EAAQ,GACZ,UAAWnB,CAAA,EAEb,KAAK,YAAYO,CAAQ,EACzB,KACF,CAEA,IAAK,mBAAoB,CACvB,GAAI,CAACP,EACH,MAAM,IAAI,MAAM,8CAA8C,EAGhE,KAAM,CAAE,IAAAM,EAAK,SAAAI,EAAU,gBAAAC,CAAA,EAAoBQ,EAAQ,QAG7CC,EAAS,MAAMX,EAAoBH,EAAKI,EAAUC,CAAe,EAGjEJ,EAA2B,CAC/B,KAAM,0BACN,GAAIY,EAAQ,GACZ,OAAAC,CAAA,EAGF,KAAK,YAAYb,EAAU,CAAE,SAAU,CAACa,EAAO,QAAQ,MAAM,EAAG,EAChE,KACF,CAEA,QAAS,CACP,MAAMb,EAA2B,CAC/B,KAAM,QACN,GAAKY,EAA4B,IAAM,UACvC,MAAO,uDAAwDA,EAA8B,IAAI,EAAA,EAEnG,KAAK,YAAYZ,CAAQ,CAC3B,CAAA,CAEJ,OAASc,EAAO,CACd,MAAMd,EAA2B,CAC/B,KAAM,QACN,GAAIY,EAAQ,GACZ,MAAOE,aAAiB,MAAQA,EAAM,QAAU,mCAAA,EAElD,KAAK,YAAYd,CAAQ,CAC3B,CACF,EAGA,KAAK,YAAY,CAAE,KAAM,QAAS"}