{"version":3,"file":"tree-processing.worker-CiRhUW6a.js","sources":["../node_modules/fflate/esm/browser.js","../node_modules/pmtiles/dist/esm/index.js","../node_modules/@mapbox/point-geometry/index.js","../node_modules/@mapbox/vector-tile/index.js","../node_modules/pbf/index.js","../src/workers/tree-processing.worker.ts"],"sourcesContent":["// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","var j=Object.defineProperty;var B=Math.pow;var l=(i,t)=>j(i,\"name\",{value:t,configurable:!0});var m=(i,t,e)=>new Promise((r,n)=>{var s=c=>{try{a(e.next(c))}catch(u){n(u)}},o=c=>{try{a(e.throw(c))}catch(u){n(u)}},a=c=>c.done?r(c.value):Promise.resolve(c.value).then(s,o);a((e=e.apply(i,t)).next())});import{decompressSync as F}from\"fflate\";var re=l((i,t)=>{let e=!1,r=\"\",n=L.GridLayer.extend({createTile:l((s,o)=>{let a=document.createElement(\"img\"),c=new AbortController,u=c.signal;return a.cancel=()=>{c.abort()},e||(i.getHeader().then(d=>{d.tileType===1?console.error(\"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"):d.tileType===2?r=\"image/png\":d.tileType===3?r=\"image/jpeg\":d.tileType===4?r=\"image/webp\":d.tileType===5&&(r=\"image/avif\")}),e=!0),i.getZxy(s.z,s.x,s.y,u).then(d=>{if(d){let h=new Blob([d.data],{type:r}),p=window.URL.createObjectURL(h);a.src=p}else a.style.display=\"none\";a.cancel=void 0,o(void 0,a)}).catch(d=>{if(d.name!==\"AbortError\")throw d}),a},\"createTile\"),_removeTile:l(function(s){let o=this._tiles[s];o&&(o.el.cancel&&o.el.cancel(),o.el.width=0,o.el.height=0,o.el.deleted=!0,L.DomUtil.remove(o.el),delete this._tiles[s],this.fire(\"tileunload\",{tile:o.el,coords:this._keyToTileCoords(s)}))},\"_removeTile\")});return new n(t)},\"leafletRasterLayer\"),W=l(i=>(t,e)=>{if(e instanceof AbortController)return i(t,e);let r=new AbortController;return i(t,r).then(n=>e(void 0,n.data,n.cacheControl||\"\",n.expires||\"\"),n=>e(n)).catch(n=>e(n)),{cancel:l(()=>r.abort(),\"cancel\")}},\"v3compat\"),E=class E{constructor(t){this.tilev4=l((t,e)=>m(this,null,function*(){if(t.type===\"json\"){let p=t.url.substr(10),y=this.tiles.get(p);if(y||(y=new w(p),this.tiles.set(p,y)),this.metadata){let z=yield y.getTileJson(t.url);return e.signal.throwIfAborted(),{data:z}}let f=yield y.getHeader();return e.signal.throwIfAborted(),(f.minLon>=f.maxLon||f.minLat>=f.maxLat)&&console.error(`Bounds of PMTiles archive ${f.minLon},${f.minLat},${f.maxLon},${f.maxLat} are not valid.`),{data:{tiles:[`${t.url}/{z}/{x}/{y}`],minzoom:f.minZoom,maxzoom:f.maxZoom,bounds:[f.minLon,f.minLat,f.maxLon,f.maxLat]}}}let r=new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/),n=t.url.match(r);if(!n)throw new Error(\"Invalid PMTiles protocol URL\");let s=n[1],o=this.tiles.get(s);o||(o=new w(s),this.tiles.set(s,o));let a=n[2],c=n[3],u=n[4],d=yield o.getHeader(),h=yield o==null?void 0:o.getZxy(+a,+c,+u,e.signal);if(e.signal.throwIfAborted(),h)return{data:new Uint8Array(h.data),cacheControl:h.cacheControl,expires:h.expires};if(d.tileType===1){if(this.errorOnMissingTile)throw new Error(\"Tile not found.\");return{data:new Uint8Array}}return{data:null}}),\"tilev4\");this.tile=W(this.tilev4);this.tiles=new Map,this.metadata=(t==null?void 0:t.metadata)||!1,this.errorOnMissingTile=(t==null?void 0:t.errorOnMissingTile)||!1}add(t){this.tiles.set(t.source.getKey(),t)}get(t){return this.tiles.get(t)}};l(E,\"Protocol\");var S=E;function b(i,t){return(t>>>0)*4294967296+(i>>>0)}l(b,\"toNum\");function N(i,t){let e=t.buf,r=e[t.pos++],n=(r&112)>>4;if(r<128||(r=e[t.pos++],n|=(r&127)<<3,r<128)||(r=e[t.pos++],n|=(r&127)<<10,r<128)||(r=e[t.pos++],n|=(r&127)<<17,r<128)||(r=e[t.pos++],n|=(r&127)<<24,r<128)||(r=e[t.pos++],n|=(r&1)<<31,r<128))return b(i,n);throw new Error(\"Expected varint not more than 10 bytes\")}l(N,\"readVarintRemainder\");function x(i){let t=i.buf,e=t[i.pos++],r=e&127;return e<128||(e=t[i.pos++],r|=(e&127)<<7,e<128)||(e=t[i.pos++],r|=(e&127)<<14,e<128)||(e=t[i.pos++],r|=(e&127)<<21,e<128)?r:(e=t[i.pos],r|=(e&15)<<28,N(r,i))}l(x,\"readVarint\");function k(i,t,e,r,n){return n===0?r!==0?[i-1-e,i-1-t]:[e,t]:[t,e]}l(k,\"rotate\");function q(i,t,e){if(i>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");if(t>=1<<i||e>=1<<i)throw new Error(\"tile x/y outside zoom level bounds\");let r=((1<<i)*(1<<i)-1)/3,n=i-1,[s,o]=[t,e];for(let a=1<<n;a>0;a>>=1){let c=s&a,u=o&a;r+=(3*c^u)*(1<<n),[s,o]=k(a,s,o,c,u),n--}return r}l(q,\"zxyToTileId\");function G(i){let t=3*i+1;return t<4294967296?31-Math.clz32(t):63-Math.clz32(t/4294967296)}l(G,\"tileIdToZ\");function ie(i){let t=G(i)>>1;if(t>26)throw new Error(\"Tile zoom level exceeds max safe number limit (26)\");let e=((1<<t)*(1<<t)-1)/3,r=i-e,n=0,s=0,o=1<<t;for(let a=1;a<o;a<<=1){let c=a&r/2,u=a&(r^c);[n,s]=k(a,n,s,c,u),r=r/2,n+=c,s+=u}return[t,n,s]}l(ie,\"tileIdToZxy\");var J=(s=>(s[s.Unknown=0]=\"Unknown\",s[s.None=1]=\"None\",s[s.Gzip=2]=\"Gzip\",s[s.Brotli=3]=\"Brotli\",s[s.Zstd=4]=\"Zstd\",s))(J||{});function D(i,t){return m(this,null,function*(){if(t===1||t===0)return i;if(t===2){if(typeof globalThis.DecompressionStream==\"undefined\")return F(new Uint8Array(i));let e=new Response(i).body;if(!e)throw new Error(\"Failed to read response stream\");let r=e.pipeThrough(new globalThis.DecompressionStream(\"gzip\"));return new Response(r).arrayBuffer()}throw new Error(\"Compression method not supported\")})}l(D,\"defaultDecompress\");var O=(o=>(o[o.Unknown=0]=\"Unknown\",o[o.Mvt=1]=\"Mvt\",o[o.Png=2]=\"Png\",o[o.Jpeg=3]=\"Jpeg\",o[o.Webp=4]=\"Webp\",o[o.Avif=5]=\"Avif\",o))(O||{});function _(i){return i===1?\".mvt\":i===2?\".png\":i===3?\".jpg\":i===4?\".webp\":i===5?\".avif\":\"\"}l(_,\"tileTypeExt\");var Y=127;function Q(i,t){let e=0,r=i.length-1;for(;e<=r;){let n=r+e>>1,s=t-i[n].tileId;if(s>0)e=n+1;else if(s<0)r=n-1;else return i[n]}return r>=0&&(i[r].runLength===0||t-i[r].tileId<i[r].runLength)?i[r]:null}l(Q,\"findTile\");var A=class A{constructor(t){this.file=t}getKey(){return this.file.name}getBytes(t,e){return m(this,null,function*(){return{data:yield this.file.slice(t,t+e).arrayBuffer()}})}};l(A,\"FileSource\");var V=A,C=class C{constructor(t,e=new Headers){var o,a;this.url=t,this.customHeaders=e,this.mustReload=!1;let r=\"\";\"navigator\"in globalThis&&(r=(a=(o=globalThis.navigator)==null?void 0:o.userAgent)!=null?a:\"\");let n=r.indexOf(\"Windows\")>-1,s=/Chrome|Chromium|Edg|OPR|Brave/.test(r);this.chromeWindowsNoCache=!1,n&&s&&(this.chromeWindowsNoCache=!0)}getKey(){return this.url}setHeaders(t){this.customHeaders=t}getBytes(t,e,r,n){return m(this,null,function*(){let s,o;r?o=r:(s=new AbortController,o=s.signal);let a=new Headers(this.customHeaders);a.set(\"range\",`bytes=${t}-${t+e-1}`);let c;this.mustReload?c=\"reload\":this.chromeWindowsNoCache&&(c=\"no-store\");let u=yield fetch(this.url,{signal:o,cache:c,headers:a});if(t===0&&u.status===416){let y=u.headers.get(\"Content-Range\");if(!y||!y.startsWith(\"bytes */\"))throw new Error(\"Missing content-length on 416 response\");let f=+y.substr(8);u=yield fetch(this.url,{signal:o,cache:\"reload\",headers:{range:`bytes=0-${f-1}`}})}let d=u.headers.get(\"Etag\");if(d!=null&&d.startsWith(\"W/\")&&(d=null),u.status===416||n&&d&&d!==n)throw this.mustReload=!0,new v(`Server returned non-matching ETag ${n} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);if(u.status>=300)throw new Error(`Bad response code: ${u.status}`);let h=u.headers.get(\"Content-Length\");if(u.status===200&&(!h||+h>e))throw s&&s.abort(),new Error(\"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\");return{data:yield u.arrayBuffer(),etag:d||void 0,cacheControl:u.headers.get(\"Cache-Control\")||void 0,expires:u.headers.get(\"Expires\")||void 0}})}};l(C,\"FetchSource\");var T=C;function g(i,t){let e=i.getUint32(t+4,!0),r=i.getUint32(t+0,!0);return e*B(2,32)+r}l(g,\"getUint64\");function X(i,t){let e=new DataView(i),r=e.getUint8(7);if(r>3)throw new Error(`Archive is spec version ${r} but this library supports up to spec version 3`);return{specVersion:r,rootDirectoryOffset:g(e,8),rootDirectoryLength:g(e,16),jsonMetadataOffset:g(e,24),jsonMetadataLength:g(e,32),leafDirectoryOffset:g(e,40),leafDirectoryLength:g(e,48),tileDataOffset:g(e,56),tileDataLength:g(e,64),numAddressedTiles:g(e,72),numTileEntries:g(e,80),numTileContents:g(e,88),clustered:e.getUint8(96)===1,internalCompression:e.getUint8(97),tileCompression:e.getUint8(98),tileType:e.getUint8(99),minZoom:e.getUint8(100),maxZoom:e.getUint8(101),minLon:e.getInt32(102,!0)/1e7,minLat:e.getInt32(106,!0)/1e7,maxLon:e.getInt32(110,!0)/1e7,maxLat:e.getInt32(114,!0)/1e7,centerZoom:e.getUint8(118),centerLon:e.getInt32(119,!0)/1e7,centerLat:e.getInt32(123,!0)/1e7,etag:t}}l(X,\"bytesToHeader\");function Z(i){let t={buf:new Uint8Array(i),pos:0},e=x(t),r=[],n=0;for(let s=0;s<e;s++){let o=x(t);r.push({tileId:n+o,offset:0,length:0,runLength:1}),n+=o}for(let s=0;s<e;s++)r[s].runLength=x(t);for(let s=0;s<e;s++)r[s].length=x(t);for(let s=0;s<e;s++){let o=x(t);o===0&&s>0?r[s].offset=r[s-1].offset+r[s-1].length:r[s].offset=o-1}return r}l(Z,\"deserializeIndex\");var U=class U extends Error{};l(U,\"EtagMismatch\");var v=U;function I(i,t){return m(this,null,function*(){let e=yield i.getBytes(0,16384);if(new DataView(e.data).getUint16(0,!0)!==19792)throw new Error(\"Wrong magic number for PMTiles archive\");let n=e.data.slice(0,Y),s=X(n,e.etag),o=e.data.slice(s.rootDirectoryOffset,s.rootDirectoryOffset+s.rootDirectoryLength),a=`${i.getKey()}|${s.etag||\"\"}|${s.rootDirectoryOffset}|${s.rootDirectoryLength}`,c=Z(yield t(o,s.internalCompression));return[s,[a,c.length,c]]})}l(I,\"getHeaderAndRoot\");function K(i,t,e,r,n){return m(this,null,function*(){let s=yield i.getBytes(e,r,void 0,n.etag),o=yield t(s.data,n.internalCompression),a=Z(o);if(a.length===0)throw new Error(\"Empty directory is invalid\");return a})}l(K,\"getDirectory\");var R=class R{constructor(t=100,e=!0,r=D){this.cache=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,r.data;let n=yield I(t,this.decompress);return n[1]&&this.cache.set(n[1][0],{lastUsed:this.counter++,data:n[1][2]}),this.cache.set(e,{lastUsed:this.counter++,data:n[0]}),this.prune(),n[0]})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,o=this.cache.get(s);if(o)return o.lastUsed=this.counter++,o.data;let a=yield K(t,this.decompress,e,r,n);return this.cache.set(s,{lastUsed:this.counter++,data:a}),this.prune(),a})}prune(){if(this.cache.size>this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){this.cache.delete(t.getKey())})}};l(R,\"ResolvedValueCache\");var $=R,M=class M{constructor(t=100,e=!0,r=D){this.cache=new Map,this.invalidations=new Map,this.maxCacheEntries=t,this.counter=1,this.decompress=r}getHeader(t){return m(this,null,function*(){let e=t.getKey(),r=this.cache.get(e);if(r)return r.lastUsed=this.counter++,yield r.data;let n=new Promise((s,o)=>{I(t,this.decompress).then(a=>{a[1]&&this.cache.set(a[1][0],{lastUsed:this.counter++,data:Promise.resolve(a[1][2])}),s(a[0]),this.prune()}).catch(a=>{o(a)})});return this.cache.set(e,{lastUsed:this.counter++,data:n}),n})}getDirectory(t,e,r,n){return m(this,null,function*(){let s=`${t.getKey()}|${n.etag||\"\"}|${e}|${r}`,o=this.cache.get(s);if(o)return o.lastUsed=this.counter++,yield o.data;let a=new Promise((c,u)=>{K(t,this.decompress,e,r,n).then(d=>{c(d),this.prune()}).catch(d=>{u(d)})});return this.cache.set(s,{lastUsed:this.counter++,data:a}),a})}prune(){if(this.cache.size>=this.maxCacheEntries){let t=1/0,e;this.cache.forEach((r,n)=>{r.lastUsed<t&&(t=r.lastUsed,e=n)}),e&&this.cache.delete(e)}}invalidate(t){return m(this,null,function*(){let e=t.getKey();if(this.invalidations.get(e))return yield this.invalidations.get(e);this.cache.delete(t.getKey());let r=new Promise((n,s)=>{this.getHeader(t).then(o=>{n(),this.invalidations.delete(e)}).catch(o=>{s(o)})});this.invalidations.set(e,r)})}};l(M,\"SharedPromiseCache\");var P=M,H=class H{constructor(t,e,r){typeof t==\"string\"?this.source=new T(t):this.source=t,r?this.decompress=r:this.decompress=D,e?this.cache=e:this.cache=new P}getHeader(){return m(this,null,function*(){return yield this.cache.getHeader(this.source)})}getZxyAttempt(t,e,r,n){return m(this,null,function*(){let s=q(t,e,r),o=yield this.cache.getHeader(this.source);if(t<o.minZoom||t>o.maxZoom)return;let a=o.rootDirectoryOffset,c=o.rootDirectoryLength;for(let u=0;u<=3;u++){let d=yield this.cache.getDirectory(this.source,a,c,o),h=Q(d,s);if(h){if(h.runLength>0){let p=yield this.source.getBytes(o.tileDataOffset+h.offset,h.length,n,o.etag);return{data:yield this.decompress(p.data,o.tileCompression),cacheControl:p.cacheControl,expires:p.expires}}a=o.leafDirectoryOffset+h.offset,c=h.length}else return}throw new Error(\"Maximum directory depth exceeded\")})}getZxy(t,e,r,n){return m(this,null,function*(){try{return yield this.getZxyAttempt(t,e,r,n)}catch(s){if(s instanceof v)return this.cache.invalidate(this.source),yield this.getZxyAttempt(t,e,r,n);throw s}})}getMetadataAttempt(){return m(this,null,function*(){let t=yield this.cache.getHeader(this.source),e=yield this.source.getBytes(t.jsonMetadataOffset,t.jsonMetadataLength,void 0,t.etag),r=yield this.decompress(e.data,t.internalCompression),n=new TextDecoder(\"utf-8\");return JSON.parse(n.decode(r))})}getMetadata(){return m(this,null,function*(){try{return yield this.getMetadataAttempt()}catch(t){if(t instanceof v)return this.cache.invalidate(this.source),yield this.getMetadataAttempt();throw t}})}getTileJson(t){return m(this,null,function*(){let e=yield this.getHeader(),r=yield this.getMetadata(),n=_(e.tileType);return{tilejson:\"3.0.0\",scheme:\"xyz\",tiles:[`${t}/{z}/{x}/{y}${n}`],vector_layers:r.vector_layers,attribution:r.attribution,description:r.description,name:r.name,version:r.version,bounds:[e.minLon,e.minLat,e.maxLon,e.maxLat],center:[e.centerLon,e.centerLat,e.centerZoom],minzoom:e.minZoom,maxzoom:e.maxZoom}})}};l(H,\"PMTiles\");var w=H;export{J as Compression,v as EtagMismatch,T as FetchSource,V as FileSource,w as PMTiles,S as Protocol,$ as ResolvedValueCache,P as SharedPromiseCache,O as TileType,X as bytesToHeader,Q as findTile,g as getUint64,re as leafletRasterLayer,x as readVarint,ie as tileIdToZxy,_ as tileTypeExt,q as zxyToTileId};\n//# sourceMappingURL=index.js.map","/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin() for .\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n","\nimport Point from '@mapbox/point-geometry';\n\n/** @import Pbf from 'pbf' */\n/** @import {Feature} from 'geojson' */\n\nexport class VectorTileFeature {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} end\n     * @param {number} extent\n     * @param {string[]} keys\n     * @param {(number | string | boolean)[]} values\n     */\n    constructor(pbf, end, extent, keys, values) {\n        // Public\n\n        /** @type {Record<string, number | string | boolean>} */\n        this.properties = {};\n\n        this.extent = extent;\n        /** @type {0 | 1 | 2 | 3} */\n        this.type = 0;\n\n        /** @type {number | undefined} */\n        this.id = undefined;\n\n        /** @private */\n        this._pbf = pbf;\n        /** @private */\n        this._geometry = -1;\n        /** @private */\n        this._keys = keys;\n        /** @private */\n        this._values = values;\n\n        pbf.readFields(readFeature, this, end);\n    }\n\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n\n        /** @type Point[][] */\n        const lines = [];\n\n        /** @type Point[] | undefined */\n        let line;\n\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n\n                if (cmd === 1) { // moveTo\n                    if (line) lines.push(line);\n                    line = [];\n                }\n\n                if (line) line.push(new Point(x, y));\n\n            } else if (cmd === 7) {\n\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (line) {\n                    line.push(line[0].clone()); // closePolygon\n                }\n\n            } else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        if (line) lines.push(line);\n\n        return lines;\n    }\n\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1,\n            length = 0,\n            x = 0,\n            y = 0,\n            x1 = Infinity,\n            x2 = -Infinity,\n            y1 = Infinity,\n            y2 = -Infinity;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1) x1 = x;\n                if (x > x2) x2 = x;\n                if (y < y1) y1 = y;\n                if (y > y2) y2 = y;\n\n            } else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        return [x1, y1, x2, y2];\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @return {Feature}\n     */\n    toGeoJSON(x, y, z) {\n        const size = this.extent * Math.pow(2, z),\n            x0 = this.extent * x,\n            y0 = this.extent * y,\n            vtCoords = this.loadGeometry();\n\n        /** @param {Point} p */\n        function projectPoint(p) {\n            return [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp((1 - (p.y + y0) * 2 / size) * Math.PI)) - 90\n            ];\n        }\n\n        /** @param {Point[]} line */\n        function projectLine(line) {\n            return line.map(projectPoint);\n        }\n\n        /** @type {Feature[\"geometry\"]} */\n        let geometry;\n\n        if (this.type === 1) {\n            const points = [];\n            for (const line of vtCoords) {\n                points.push(line[0]);\n            }\n            const coordinates = projectLine(points);\n            geometry = points.length === 1 ?\n                {type: 'Point', coordinates: coordinates[0]} :\n                {type: 'MultiPoint', coordinates};\n\n        } else if (this.type === 2) {\n\n            const coordinates = vtCoords.map(projectLine);\n            geometry = coordinates.length === 1 ?\n                {type: 'LineString', coordinates: coordinates[0]} :\n                {type: 'MultiLineString', coordinates};\n\n        } else if (this.type === 3) {\n            const polygons = classifyRings(vtCoords);\n            const coordinates = [];\n            for (const polygon of polygons) {\n                coordinates.push(polygon.map(projectLine));\n            }\n            geometry = coordinates.length === 1 ?\n                {type: 'Polygon', coordinates: coordinates[0]} :\n                {type: 'MultiPolygon', coordinates};\n        } else {\n\n            throw new Error('unknown feature type');\n        }\n\n        /** @type {Feature} */\n        const result = {\n            type: 'Feature',\n            geometry,\n            properties: this.properties\n        };\n\n        if (this.id != null) {\n            result.id = this.id;\n        }\n\n        return result;\n    }\n}\n\n/** @type {['Unknown', 'Point', 'LineString', 'Polygon']} */\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\n/**\n * @param {number} tag\n * @param {VectorTileFeature} feature\n * @param {Pbf} pbf\n */\nfunction readFeature(tag, feature, pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = /** @type {0 | 1 | 2 | 3} */ (pbf.readVarint());\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 4) feature._geometry = pbf.pos;\n}\n\n/**\n * @param {Pbf} pbf\n * @param {VectorTileFeature} feature\n */\nfunction readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        // @ts-expect-error TS2341 deliberately accessing a private property\n        const key = feature._keys[pbf.readVarint()];\n        // @ts-expect-error TS2341 deliberately accessing a private property\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\n/** classifies an array of rings into polygons with outer rings and holes\n * @param {Point[][]} rings\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    const polygons = [];\n    let polygon, ccw;\n\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else if (polygon) {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\n/** @param {Point[]} ring */\nfunction signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\nexport class VectorTileLayer {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n\n        /** @private */\n        this._pbf = pbf;\n\n        /** @private\n         * @type {string[]} */\n        this._keys = [];\n\n        /** @private\n         * @type {(number | string | boolean)[]} */\n        this._values = [];\n\n        /** @private\n         * @type {number[]} */\n        this._features = [];\n\n        pbf.readFields(readLayer, this, end);\n\n        this.length = this._features.length;\n    }\n\n    /** return feature `i` from this layer as a `VectorTileFeature`\n     * @param {number} i\n     */\n    feature(i) {\n        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n        this._pbf.pos = this._features[i];\n\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {VectorTileLayer} layer\n * @param {Pbf} pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 2) layer._features.push(pbf.pos);\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    // @ts-expect-error TS2341 deliberately accessing a private property\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\n/**\n * @param {Pbf} pbf\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n    if (value == null) {\n        throw new Error('unknown feature value');\n    }\n\n    return value;\n}\n\nexport class VectorTile {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        /** @type {Record<string, VectorTileLayer>} */\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {Record<string, VectorTileLayer>} layers\n * @param {Pbf} pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n","\nconst SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nconst SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// Threshold chosen based on both benchmarking and knowledge about browser string\n// data structures (which currently switch structure types at 12 bytes or more)\nconst TEXT_DECODER_MIN_LENGTH = 12;\nconst utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8');\n\nconst PBF_VARINT  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nconst PBF_FIXED64 = 1; // 64-bit: double, fixed64, sfixed64\nconst PBF_BYTES   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nconst PBF_FIXED32 = 5; // 32-bit: float, fixed32, sfixed32\n\nexport default class Pbf {\n    /**\n     * @param {Uint8Array | ArrayBuffer} [buf]\n     */\n    constructor(buf = new Uint8Array(16)) {\n        this.buf = ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf);\n        this.dataView = new DataView(this.buf.buffer);\n        this.pos = 0;\n        this.type = 0;\n        this.length = this.buf.length;\n    }\n\n    // === READING =================================================================\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     * @param {number} [end]\n     */\n    readFields(readField, result, end = this.length) {\n        while (this.pos < end) {\n            const val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    }\n\n    /**\n     * @template T\n     * @param {(tag: number, result: T, pbf: Pbf) => void} readField\n     * @param {T} result\n     */\n    readMessage(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    }\n\n    readFixed32() {\n        const val = this.dataView.getUint32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readSFixed32() {\n        const val = this.dataView.getInt32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readSFixed64() {\n        const val = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    }\n\n    readFloat() {\n        const val = this.dataView.getFloat32(this.pos, true);\n        this.pos += 4;\n        return val;\n    }\n\n    readDouble() {\n        const val = this.dataView.getFloat64(this.pos, true);\n        this.pos += 8;\n        return val;\n    }\n\n    /**\n     * @param {boolean} [isSigned]\n     */\n    readVarint(isSigned) {\n        const buf = this.buf;\n        let val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    }\n\n    readVarint64() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    }\n\n    readSVarint() {\n        const num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    }\n\n    readBoolean() {\n        return Boolean(this.readVarint());\n    }\n\n    readString() {\n        const end = this.readVarint() + this.pos;\n        const pos = this.pos;\n        this.pos = end;\n\n        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n            // longer strings are fast with the built-in browser TextDecoder API\n            return utf8TextDecoder.decode(this.buf.subarray(pos, end));\n        }\n        // short strings are fast with our custom implementation\n        return readUtf8(this.buf, pos, end);\n    }\n\n    readBytes() {\n        const end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    }\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    /**\n     * @param {number[]} [arr]\n     * @param {boolean} [isSigned]\n     */\n    readPackedVarint(arr = [], isSigned) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSVarint(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    }\n    /** @param {boolean[]} [arr] */\n    readPackedBoolean(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFloat(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedDouble(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed32(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    }\n    /** @param {number[]} [arr] */\n    readPackedSFixed64(arr = []) {\n        const end = this.readPackedEnd();\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    }\n    readPackedEnd() {\n        return this.type === PBF_BYTES ? this.readVarint() + this.pos : this.pos + 1;\n    }\n\n    /** @param {number} val */\n    skip(val) {\n        const type = val & 0x7;\n        if (type === PBF_VARINT) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === PBF_BYTES) this.pos = this.readVarint() + this.pos;\n        else if (type === PBF_FIXED32) this.pos += 4;\n        else if (type === PBF_FIXED64) this.pos += 8;\n        else throw new Error(`Unimplemented type: ${type}`);\n    }\n\n    // === WRITING =================================================================\n\n    /**\n     * @param {number} tag\n     * @param {number} type\n     */\n    writeTag(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    }\n\n    /** @param {number} min */\n    realloc(min) {\n        let length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            const buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.dataView = new DataView(buf.buffer);\n            this.length = length;\n        }\n    }\n\n    finish() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    }\n\n    /** @param {number} val */\n    writeFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeSFixed32(val) {\n        this.realloc(4);\n        this.dataView.setInt32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeSFixed64(val) {\n        this.realloc(8);\n        this.dataView.setInt32(this.pos, val & -1, true);\n        this.dataView.setInt32(this.pos + 4, Math.floor(val * SHIFT_RIGHT_32), true);\n        this.pos += 8;\n    }\n\n    /** @param {number} val */\n    writeVarint(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    }\n\n    /** @param {number} val */\n    writeSVarint(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    }\n\n    /** @param {boolean} val */\n    writeBoolean(val) {\n        this.writeVarint(+val);\n    }\n\n    /** @param {string} str */\n    writeString(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        const startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /** @param {number} val */\n    writeFloat(val) {\n        this.realloc(4);\n        this.dataView.setFloat32(this.pos, val, true);\n        this.pos += 4;\n    }\n\n    /** @param {number} val */\n    writeDouble(val) {\n        this.realloc(8);\n        this.dataView.setFloat64(this.pos, val, true);\n        this.pos += 8;\n    }\n\n    /** @param {Uint8Array} buffer */\n    writeBytes(buffer) {\n        const len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (let i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    }\n\n    /**\n     * @template T\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeRawMessage(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        const startPos = this.pos;\n        fn(obj, this);\n        const len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    }\n\n    /**\n     * @template T\n     * @param {number} tag\n     * @param {(obj: T, pbf: Pbf) => void} fn\n     * @param {T} obj\n     */\n    writeMessage(tag, fn, obj) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeRawMessage(fn, obj);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSVarint(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean[]} arr\n     */\n    writePackedBoolean(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFloat(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedDouble(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed32(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);\n    }\n    /**\n     * @param {number} tag\n     * @param {number[]} arr\n     */\n    writePackedSFixed64(tag, arr) {\n        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);\n    }\n\n    /**\n     * @param {number} tag\n     * @param {Uint8Array} buffer\n     */\n    writeBytesField(tag, buffer) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeBytes(buffer);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed32Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeSFixed32(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSFixed64Field(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeSFixed64(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeSVarintField(tag, val) {\n        this.writeTag(tag, PBF_VARINT);\n        this.writeSVarint(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {string} str\n     */\n    writeStringField(tag, str) {\n        this.writeTag(tag, PBF_BYTES);\n        this.writeString(str);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeFloatField(tag, val) {\n        this.writeTag(tag, PBF_FIXED32);\n        this.writeFloat(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {number} val\n     */\n    writeDoubleField(tag, val) {\n        this.writeTag(tag, PBF_FIXED64);\n        this.writeDouble(val);\n    }\n    /**\n     * @param {number} tag\n     * @param {boolean} val\n     */\n    writeBooleanField(tag, val) {\n        this.writeVarintField(tag, +val);\n    }\n};\n\n/**\n * @param {number} l\n * @param {boolean | undefined} s\n * @param {Pbf} p\n */\nfunction readVarintRemainder(l, s, p) {\n    const buf = p.buf;\n    let h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {boolean} [isSigned]\n */\nfunction toNum(low, high, isSigned) {\n    return isSigned ? high * 0x100000000 + (low >>> 0) : ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\n/**\n * @param {number} val\n * @param {Pbf} pbf\n */\nfunction writeBigVarint(val, pbf) {\n    let low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\n/**\n * @param {number} high\n * @param {number} low\n * @param {Pbf} pbf\n */\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\n/**\n * @param {number} high\n * @param {Pbf} pbf\n */\nfunction writeBigVarintHigh(high, pbf) {\n    const lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\n/**\n * @param {number} startPos\n * @param {number} len\n * @param {Pbf} pbf\n */\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    const extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (let i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSVarint(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFloat(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedDouble(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);\n}\n/**\n * @param {boolean[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedBoolean(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed32(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);\n}\n/**\n * @param {number[]} arr\n * @param {Pbf} pbf\n */\nfunction writePackedSFixed64(arr, pbf) {\n    for (let i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);\n}\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\n/**\n * @param {Uint8Array} buf\n * @param {number} pos\n * @param {number} end\n */\nfunction readUtf8(buf, pos, end) {\n    let str = '';\n    let i = pos;\n\n    while (i < end) {\n        const b0 = buf[i];\n        let c = null; // codepoint\n        let bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        let b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {string} str\n * @param {number} pos\n */\nfunction writeUtf8(buf, str, pos) {\n    for (let i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","/**\n * Tree processing worker\n * Handles CPU-intensive tree generation, spatial filtering, AND data fetching\n * all off the main thread to avoid structured clone overhead.\n *\n * Like full-pipeline worker, this fetches PMTiles data directly in the worker\n * to avoid sending large feature arrays over the message channel.\n */\n\nimport { PMTiles } from 'pmtiles';\nimport { VectorTile } from '@mapbox/vector-tile';\nimport Pbf from 'pbf';\nimport type {\n  WorkerResponse,\n  ProcessTreesResult,\n  TreeData,\n  ParsedFeature,\n  LandcoverTreeConfig,\n  TileBounds,\n  ElevationConfig,\n} from './types.js';\n\n// ============================================================================\n// PMTILES INITIALIZATION\n// ============================================================================\n\n// PMTiles sources (lazy initialized)\nlet basePMTiles: PMTiles | null = null;\nlet buildingsPMTiles: PMTiles | null = null;\nlet transportationPMTiles: PMTiles | null = null;\nlet pmtilesInitialized = false;\nlet pmtilesInitPromise: Promise<void> | null = null;\n\n// Cached URLs for initialization\nlet basePMTilesUrl: string | null = null;\nlet buildingsPMTilesUrl: string | null = null;\nlet transportationPMTilesUrl: string | null = null;\n\n// ============================================================================\n// TREE HINTS DATA (from tree-tiles.bin)\n// ============================================================================\n\ninterface TileHint {\n  count: number;\n  coniferRatio: number;\n}\n\n// Tree hints data: Map<packedXY => packedValue>\n// Memory optimization: uses packed integers instead of string keys and object values\n// Key: (x << 16) | y (uint32)\n// Value: (count << 8) | coniferRatioUint8 (uint32)\n// This reduces memory from ~113MB to ~18MB per worker for ~750k entries\nlet treeHintsData: Map<number, number> | null = null;\nlet treeHintsLoadPromise: Promise<void> | null = null;\nlet treeHintsUrl: string | null = null;\nlet treeHintsZoom: number = 10; // Default, will be updated from file\n\n/** Pack x,y coordinates into a single uint32 key */\nfunction packKey(x: number, y: number): number {\n  return (x << 16) | y;\n}\n\n/** Pack count and coniferRatio into a single uint32 value */\nfunction packValue(count: number, coniferRatioUint8: number): number {\n  return (count << 8) | coniferRatioUint8;\n}\n\n/** Unpack value into count and coniferRatio */\nfunction unpackValue(packed: number): TileHint {\n  return {\n    count: packed >>> 8,\n    coniferRatio: (packed & 0xFF) / 255\n  };\n}\n\n/**\n * Load and parse tree-tiles.bin (runs entirely in worker)\n */\nasync function loadTreeHints(url: string): Promise<void> {\n  // Already loaded with same URL\n  if (treeHintsData !== null && treeHintsUrl === url) {\n    return;\n  }\n\n  // Already loading\n  if (treeHintsLoadPromise !== null && treeHintsUrl === url) {\n    return treeHintsLoadPromise;\n  }\n\n  treeHintsUrl = url;\n  treeHintsLoadPromise = (async () => {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Failed to load tree-tiles.bin: HTTP ${response.status}`);\n      }\n\n      const buffer = await response.arrayBuffer();\n      const data = new DataView(buffer);\n\n      // Parse header\n      const magic = String.fromCharCode(\n        data.getUint8(0),\n        data.getUint8(1),\n        data.getUint8(2),\n        data.getUint8(3)\n      );\n\n      if (magic !== 'TREE') {\n        throw new Error('Invalid tree-tiles.bin magic bytes');\n      }\n\n      const version = data.getUint8(4);\n      const zoom = data.getUint8(5);\n      treeHintsZoom = zoom;\n\n      let offset: number;\n      let tileCount: number;\n\n      if (version === 1) {\n        tileCount = data.getUint16(6, true);\n        offset = 8;\n      } else if (version === 2) {\n        tileCount = data.getUint32(6, true);\n        offset = 10;\n      } else {\n        throw new Error(`Unsupported tree-tiles.bin version: ${version}`);\n      }\n\n      // Parse tiles into memory-efficient packed format\n      treeHintsData = new Map();\n\n      for (let i = 0; i < tileCount; i++) {\n        const x = data.getUint16(offset, true); offset += 2;\n        const y = data.getUint16(offset, true); offset += 2;\n        const count = data.getUint16(offset, true); offset += 2;\n        const coniferRatioUint8 = data.getUint8(offset); offset += 1;\n\n        treeHintsData.set(packKey(x, y), packValue(count, coniferRatioUint8));\n      }\n    } catch (error) {\n      console.warn('[TreeWorker] Failed to load tree hints:', (error as Error).message);\n      // Graceful degradation: use empty map\n      treeHintsData = new Map();\n    }\n  })();\n\n  return treeHintsLoadPromise;\n}\n\n/**\n * Get tree hint for a tile (converts from detail zoom to hints zoom)\n * Uses the treeHintsZoom loaded from the file header\n */\nfunction getTileHint(tileX: number, tileY: number, tileZ: number): TileHint | null {\n  if (!treeHintsData) return null;\n\n  // Use the zoom level loaded from the tree-tiles.bin file header\n  const hintsZoom = treeHintsZoom;\n\n  let hx: number, hy: number;\n\n  // Convert from detail tile coords to hints tile coords\n  if (tileZ === hintsZoom) {\n    hx = tileX;\n    hy = tileY;\n  } else if (tileZ > hintsZoom) {\n    // Detail tile is smaller, scale down\n    const scale = Math.pow(2, tileZ - hintsZoom);\n    hx = Math.floor(tileX / scale);\n    hy = Math.floor(tileY / scale);\n  } else {\n    // Detail tile is larger than hints tile - use center\n    const scale = Math.pow(2, hintsZoom - tileZ);\n    hx = tileX * scale + Math.floor(scale / 2);\n    hy = tileY * scale + Math.floor(scale / 2);\n  }\n\n  const packed = treeHintsData.get(packKey(hx, hy));\n  return packed !== undefined ? unpackValue(packed) : null;\n}\n\n/**\n * Initialize PMTiles sources (called once, lazy)\n */\nasync function initializePMTiles(\n  baseUrl: string,\n  buildingsUrl: string,\n  transportUrl: string\n): Promise<void> {\n  // Already initialized with matching URLs\n  if (\n    pmtilesInitialized &&\n    basePMTilesUrl === baseUrl &&\n    buildingsPMTilesUrl === buildingsUrl &&\n    transportationPMTilesUrl === transportUrl\n  ) {\n    return;\n  }\n\n  // If there's a pending init, wait for it\n  if (pmtilesInitPromise) {\n    if (\n      basePMTilesUrl !== baseUrl ||\n      buildingsPMTilesUrl !== buildingsUrl ||\n      transportationPMTilesUrl !== transportUrl\n    ) {\n      await pmtilesInitPromise;\n      pmtilesInitialized = false;\n    } else {\n      await pmtilesInitPromise;\n      return;\n    }\n  }\n\n  pmtilesInitPromise = (async () => {\n    try {\n      basePMTilesUrl = baseUrl;\n      buildingsPMTilesUrl = buildingsUrl;\n      transportationPMTilesUrl = transportUrl;\n\n      basePMTiles = new PMTiles(baseUrl);\n      buildingsPMTiles = new PMTiles(buildingsUrl);\n      transportationPMTiles = new PMTiles(transportUrl);\n\n      // Verify headers are accessible (validates CORS)\n      await Promise.all([\n        basePMTiles.getHeader(),\n        buildingsPMTiles.getHeader(),\n        transportationPMTiles.getHeader(),\n      ]);\n\n      pmtilesInitialized = true;\n    } catch (error) {\n      console.error('[TreeProcessingWorker] Failed to initialize PMTiles:', error);\n      basePMTiles = null;\n      buildingsPMTiles = null;\n      transportationPMTiles = null;\n      basePMTilesUrl = null;\n      buildingsPMTilesUrl = null;\n      transportationPMTilesUrl = null;\n      pmtilesInitialized = false;\n      throw error;\n    }\n  })();\n\n  try {\n    await pmtilesInitPromise;\n  } finally {\n    pmtilesInitPromise = null;\n  }\n}\n\n// ============================================================================\n// TILE FETCHING AND PARSING\n// ============================================================================\n\n/**\n * Fetch tile data from PMTiles\n */\nasync function fetchTileData(\n  pmtiles: PMTiles,\n  z: number,\n  x: number,\n  y: number\n): Promise<ArrayBuffer | null> {\n  try {\n    const result = await pmtiles.getZxy(z, x, y);\n    return result?.data ?? null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse MVT data to features\n */\nfunction parseMVT(\n  data: ArrayBuffer,\n  tileX: number,\n  tileY: number,\n  zoom: number,\n  layerName: string | null = null\n): ParsedFeature[] {\n  const tile = new VectorTile(new Pbf(data));\n  const features: ParsedFeature[] = [];\n\n  const allLayerNames = Object.keys(tile.layers);\n  const layerNames = layerName && tile.layers[layerName] ? [layerName] : allLayerNames;\n\n  for (const name of layerNames) {\n    const layer = tile.layers[name];\n    if (!layer) continue;\n\n    for (let i = 0; i < layer.length; i++) {\n      const feature = layer.feature(i);\n      const geojson = feature.toGeoJSON(tileX, tileY, zoom);\n\n      features.push({\n        type: geojson.geometry.type,\n        coordinates: geojson.geometry.coordinates,\n        properties: feature.properties as Record<string, unknown>,\n        layer: name,\n      });\n    }\n  }\n\n  return features;\n}\n\n/**\n * Calculate tile bounds from tile coordinates\n */\nfunction tileToBounds(x: number, y: number, z: number): TileBounds {\n  const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);\n  const north = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n\n  const n2 = Math.PI - (2 * Math.PI * (y + 1)) / Math.pow(2, z);\n  const south = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));\n\n  const west = (x / Math.pow(2, z)) * 360 - 180;\n  const east = ((x + 1) / Math.pow(2, z)) * 360 - 180;\n\n  return { north, south, west, east };\n}\n\n// ============================================================================\n// ELEVATION TILE HANDLING\n// ============================================================================\n\ninterface CachedElevationTile {\n  heights: Float32Array;\n  bounds: { west: number; east: number; north: number; south: number };\n}\n\n// In-memory cache for elevation tiles within this worker\nconst elevationCache = new Map<string, CachedElevationTile>();\n\n/**\n * Convert lng/lat to tile coordinates\n */\nfunction lngLatToTile(lng: number, lat: number, zoom: number): [number, number] {\n  const n = Math.pow(2, zoom);\n  const x = Math.floor(((lng + 180) / 360) * n);\n  const latRad = (lat * Math.PI) / 180;\n  const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);\n  return [x, y];\n}\n\n/**\n * Get elevation tile bounds\n */\nfunction elevationTileToBounds(x: number, y: number, zoom: number): { west: number; east: number; north: number; south: number } {\n  const n = Math.pow(2, zoom);\n  const west = (x / n) * 360 - 180;\n  const east = ((x + 1) / n) * 360 - 180;\n  const north = Math.atan(Math.sinh(Math.PI * (1 - (2 * y) / n))) * (180 / Math.PI);\n  const south = Math.atan(Math.sinh(Math.PI * (1 - (2 * (y + 1)) / n))) * (180 / Math.PI);\n  return { west, east, north, south };\n}\n\n/**\n * Decode Terrarium RGB to height\n */\nfunction decodeTerrarium(r: number, g: number, b: number, offset: number): number {\n  return (r * 256 + g + b / 256) - offset;\n}\n\n/**\n * Fetch and decode an elevation tile\n */\nasync function fetchElevationTile(\n  x: number,\n  y: number,\n  config: ElevationConfig\n): Promise<CachedElevationTile | null> {\n  const key = `${config.zoom}/${x}/${y}`;\n\n  // Check cache first\n  const cached = elevationCache.get(key);\n  if (cached) return cached;\n\n  const url = config.urlTemplate\n    .replace('{z}', config.zoom.toString())\n    .replace('{x}', x.toString())\n    .replace('{y}', y.toString());\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) return null;\n\n    const blob = await response.blob();\n    const bitmap = await createImageBitmap(blob);\n\n    // Draw to offscreen canvas to get pixel data\n    const canvas = new OffscreenCanvas(config.tileSize, config.tileSize);\n    const ctx = canvas.getContext('2d')!;\n    ctx.drawImage(bitmap, 0, 0, config.tileSize, config.tileSize);\n\n    const imageData = ctx.getImageData(0, 0, config.tileSize, config.tileSize);\n    const heights = new Float32Array(config.tileSize * config.tileSize);\n\n    for (let i = 0; i < config.tileSize * config.tileSize; i++) {\n      const r = imageData.data[i * 4];\n      const g = imageData.data[i * 4 + 1];\n      const b = imageData.data[i * 4 + 2];\n      heights[i] = decodeTerrarium(r, g, b, config.terrariumOffset);\n    }\n\n    const bounds = elevationTileToBounds(x, y, config.zoom);\n    const tile: CachedElevationTile = { heights, bounds };\n    elevationCache.set(key, tile);\n\n    return tile;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Bilinear interpolation on height grid\n */\nfunction bilinearInterpolate(\n  heights: Float32Array,\n  gridX: number,\n  gridY: number,\n  gridSize: number\n): number {\n  const clampedX = Math.max(0, Math.min(gridSize - 1, gridX));\n  const clampedY = Math.max(0, Math.min(gridSize - 1, gridY));\n\n  const x0 = Math.floor(clampedX);\n  const y0 = Math.floor(clampedY);\n  const x1 = Math.min(x0 + 1, gridSize - 1);\n  const y1 = Math.min(y0 + 1, gridSize - 1);\n\n  const fx = clampedX - x0;\n  const fy = clampedY - y0;\n\n  const h00 = heights[y0 * gridSize + x0];\n  const h10 = heights[y0 * gridSize + x1];\n  const h01 = heights[y1 * gridSize + x0];\n  const h11 = heights[y1 * gridSize + x1];\n\n  // Handle NaN values\n  const corners = [h00, h10, h01, h11];\n  const validCorners = corners.filter(h => !Number.isNaN(h));\n  if (validCorners.length === 0) return 0;\n\n  if (validCorners.length < 4) {\n    const avg = validCorners.reduce((a, b) => a + b, 0) / validCorners.length;\n    const h00Safe = Number.isNaN(h00) ? avg : h00;\n    const h10Safe = Number.isNaN(h10) ? avg : h10;\n    const h01Safe = Number.isNaN(h01) ? avg : h01;\n    const h11Safe = Number.isNaN(h11) ? avg : h11;\n    return h00Safe * (1 - fx) * (1 - fy) + h10Safe * fx * (1 - fy) + h01Safe * (1 - fx) * fy + h11Safe * fx * fy;\n  }\n\n  return h00 * (1 - fx) * (1 - fy) + h10 * fx * (1 - fy) + h01 * (1 - fx) * fy + h11 * fx * fy;\n}\n\n/**\n * Get terrain height at a coordinate using cached elevation tiles\n */\nfunction getTerrainHeightFromCache(\n  lng: number,\n  lat: number,\n  config: ElevationConfig\n): number {\n  const [tileX, tileY] = lngLatToTile(lng, lat, config.zoom);\n  const key = `${config.zoom}/${tileX}/${tileY}`;\n\n  const cached = elevationCache.get(key);\n  if (!cached) return 0;\n\n  const { heights, bounds } = cached;\n\n  // Calculate position within tile\n  const relX = (lng - bounds.west) / (bounds.east - bounds.west);\n  const relY = (bounds.north - lat) / (bounds.north - bounds.south);\n\n  const gridX = relX * (config.tileSize - 1);\n  const gridY = relY * (config.tileSize - 1);\n\n  const height = bilinearInterpolate(heights, gridX, gridY, config.tileSize);\n  return Number.isNaN(height) ? 0 : height;\n}\n\n/**\n * Prefetch all elevation tiles needed for tree positions\n */\nasync function prefetchElevationTilesForTrees(\n  trees: TreeData[],\n  config: ElevationConfig\n): Promise<void> {\n  const neededTiles = new Set<string>();\n\n  // Collect all unique tile coordinates\n  for (const tree of trees) {\n    const [tileX, tileY] = lngLatToTile(tree.lng, tree.lat, config.zoom);\n    neededTiles.add(`${tileX}/${tileY}`);\n  }\n\n  // Fetch all tiles in parallel\n  const fetchPromises: Promise<CachedElevationTile | null>[] = [];\n  for (const tileKey of neededTiles) {\n    const [x, y] = tileKey.split('/').map(Number);\n    fetchPromises.push(fetchElevationTile(x, y, config));\n  }\n\n  await Promise.all(fetchPromises);\n}\n\n/**\n * Compute terrain heights for all trees\n */\nasync function computeTerrainHeightsForTrees(\n  trees: TreeData[],\n  config: ElevationConfig,\n  verticalExaggeration: number\n): Promise<void> {\n  // Prefetch elevation tiles\n  await prefetchElevationTilesForTrees(trees, config);\n\n  // Compute heights\n  for (const tree of trees) {\n    const rawHeight = getTerrainHeightFromCache(tree.lng, tree.lat, config);\n    tree.terrainHeight = rawHeight * verticalExaggeration;\n  }\n}\n\n// Lower zoom levels to check for water polygons\nconst WATER_ZOOM_LEVELS = [12, 11, 10, 9, 8];\n\n/**\n * Load base tile features\n */\nasync function loadBaseTile(x: number, y: number, zoom: number): Promise<ParsedFeature[]> {\n  if (!basePMTiles) return [];\n\n  const data = await fetchTileData(basePMTiles, zoom, x, y);\n  if (data) {\n    return parseMVT(data, x, y, zoom);\n  }\n  return [];\n}\n\n/**\n * Load water polygons from lower zoom levels for better coverage\n */\nasync function loadWaterPolygons(x: number, y: number, zoom: number): Promise<ParsedFeature[]> {\n  if (!basePMTiles) return [];\n\n  const features: ParsedFeature[] = [];\n  const seenPolygons = new Set<string>();\n\n  for (const fallbackZoom of WATER_ZOOM_LEVELS) {\n    if (fallbackZoom > zoom) continue;\n\n    const scale = Math.pow(2, zoom - fallbackZoom);\n    const fallbackX = Math.floor(x / scale);\n    const fallbackY = Math.floor(y / scale);\n\n    const data = await fetchTileData(basePMTiles, fallbackZoom, fallbackX, fallbackY);\n    if (data) {\n      const allFeatures = parseMVT(data, fallbackX, fallbackY, fallbackZoom, 'water');\n      for (const feature of allFeatures) {\n        if (feature.type === 'Polygon' || feature.type === 'MultiPolygon') {\n          // Deduplicate by coordinates hash\n          const coordHash = JSON.stringify(feature.coordinates).slice(0, 100);\n          if (!seenPolygons.has(coordHash)) {\n            seenPolygons.add(coordHash);\n            features.push(feature);\n          }\n        }\n      }\n    }\n  }\n\n  return features;\n}\n\n/**\n * Load building tile features\n */\nasync function loadBuildingTile(x: number, y: number, zoom: number): Promise<ParsedFeature[]> {\n  if (!buildingsPMTiles) return [];\n\n  const data = await fetchTileData(buildingsPMTiles, zoom, x, y);\n  if (data) {\n    return parseMVT(data, x, y, zoom);\n  }\n  return [];\n}\n\n/**\n * Load transportation tile features\n */\nasync function loadTransportationTile(x: number, y: number, zoom: number): Promise<ParsedFeature[]> {\n  if (!transportationPMTiles) return [];\n\n  const data = await fetchTileData(transportationPMTiles, zoom, x, y);\n  if (data) {\n    return parseMVT(data, x, y, zoom);\n  }\n  return [];\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Simple seeded random number generator for consistent procedural generation\n */\nfunction seededRandom(seed: number): () => number {\n  let state = seed;\n  return () => {\n    state = (state * 1103515245 + 12345) & 0x7fffffff;\n    return state / 0x7fffffff;\n  };\n}\n\n/**\n * Create a seed from tile coordinates for consistent tree placement\n */\nfunction getTileSeed(tileX: number, tileY: number, tileZ: number): number {\n  return ((tileX * 73856093) ^ (tileY * 19349663) ^ (tileZ * 83492791)) & 0x7fffffff;\n}\n\n/**\n * Point-in-polygon test using ray casting algorithm\n */\nfunction pointInPolygon(x: number, y: number, polygon: number[][]): boolean {\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i][0], yi = polygon[i][1];\n    const xj = polygon[j][0], yj = polygon[j][1];\n\n    if (((yi > y) !== (yj > y)) &&\n        (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n      inside = !inside;\n    }\n  }\n  return inside;\n}\n\n/**\n * Calculate the approximate area of a polygon in square meters\n */\nfunction calculatePolygonAreaMeters(polygon: number[][]): number {\n  if (polygon.length < 3) return 0;\n\n  let centroidLat = 0;\n  for (const [, lat] of polygon) {\n    centroidLat += lat;\n  }\n  centroidLat /= polygon.length;\n\n  let area = 0;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    area += (polygon[j][0] + polygon[i][0]) * (polygon[j][1] - polygon[i][1]);\n  }\n  area = Math.abs(area / 2);\n\n  const metersPerDegreeLat = 111320;\n  const metersPerDegreeLng = 111320 * Math.cos(centroidLat * Math.PI / 180);\n  return area * metersPerDegreeLat * metersPerDegreeLng;\n}\n\n/**\n * Get the bounding box of a polygon\n */\nfunction getPolygonBounds(polygon: number[][]): { minLng: number; maxLng: number; minLat: number; maxLat: number } {\n  let minLng = Infinity, maxLng = -Infinity;\n  let minLat = Infinity, maxLat = -Infinity;\n\n  for (const [lng, lat] of polygon) {\n    if (lng < minLng) minLng = lng;\n    if (lng > maxLng) maxLng = lng;\n    if (lat < minLat) minLat = lat;\n    if (lat > maxLat) maxLat = lat;\n  }\n\n  return { minLng, maxLng, minLat, maxLat };\n}\n\n// ============================================================================\n// TREE GENERATION\n// ============================================================================\n\n/**\n * Generate trees within a single polygon based on landcover type\n */\nfunction generateTreesInPolygon(\n  polygon: number[][],\n  _subtype: string,\n  config: LandcoverTreeConfig,\n  random: () => number,\n  maxTrees: number\n): TreeData[] {\n  const trees: TreeData[] = [];\n  const areaSqMeters = calculatePolygonAreaMeters(polygon);\n\n  // Calculate number of trees based on area and density\n  const treesPerHectare = config.density;\n  const areaHectares = areaSqMeters / 10000;\n  let targetTreeCount = Math.ceil(areaHectares * treesPerHectare);\n  targetTreeCount = Math.min(targetTreeCount, maxTrees);\n\n  if (targetTreeCount <= 0) return trees;\n\n  // Get polygon bounds for rejection sampling\n  const bounds = getPolygonBounds(polygon);\n\n  // Generate trees using rejection sampling\n  let attempts = 0;\n  const maxAttempts = targetTreeCount * 10;\n\n  while (trees.length < targetTreeCount && attempts < maxAttempts) {\n    attempts++;\n\n    const lng = bounds.minLng + random() * (bounds.maxLng - bounds.minLng);\n    const lat = bounds.minLat + random() * (bounds.maxLat - bounds.minLat);\n\n    if (!pointInPolygon(lng, lat, polygon)) {\n      continue;\n    }\n\n    // Determine tree type based on config\n    const isConifer = random() < config.coniferRatio;\n    const leafType = isConifer ? 'needleleaved' : 'broadleaved';\n\n    // Calculate height with variation\n    const baseHeight = config.minHeight + random() * (config.maxHeight - config.minHeight);\n    const height = baseHeight + (random() - 0.5) * 2 * config.heightVariation;\n\n    trees.push({\n      lat,\n      lng,\n      height: Math.max(config.minHeight, Math.min(config.maxHeight, height)),\n      leafType,\n    });\n  }\n\n  return trees;\n}\n\n/**\n * Generate procedural trees from landcover polygons\n */\nfunction generateProceduralTrees(\n  features: ParsedFeature[],\n  tileX: number,\n  tileY: number,\n  tileZ: number,\n  landcoverConfig: Record<string, LandcoverTreeConfig>,\n  maxTrees: number\n): TreeData[] {\n  const seed = getTileSeed(tileX, tileY, tileZ);\n  const random = seededRandom(seed);\n\n  const allTrees: TreeData[] = [];\n\n  for (const feature of features) {\n    if (feature.layer !== 'land_cover') continue;\n\n    const subtype = (feature.properties.subtype as string) || '';\n    const config = landcoverConfig[subtype];\n    if (!config) continue;\n\n    const remainingSlots = maxTrees - allTrees.length;\n    if (remainingSlots <= 0) break;\n\n    if (feature.type === 'Polygon') {\n      const rings = feature.coordinates as number[][][];\n      if (rings.length > 0) {\n        const trees = generateTreesInPolygon(rings[0], subtype, config, random, remainingSlots);\n        allTrees.push(...trees);\n      }\n    } else if (feature.type === 'MultiPolygon') {\n      const polygons = feature.coordinates as number[][][][];\n      for (const rings of polygons) {\n        const remaining = maxTrees - allTrees.length;\n        if (remaining <= 0) break;\n        if (rings.length > 0) {\n          const trees = generateTreesInPolygon(rings[0], subtype, config, random, remaining);\n          allTrees.push(...trees);\n        }\n      }\n    }\n  }\n\n  return allTrees;\n}\n\n/**\n * Generate trees based on OSM density data\n */\nfunction generateOSMDensityTrees(\n  tileX: number,\n  tileY: number,\n  tileZ: number,\n  bounds: TileBounds,\n  tileHint: { count: number; coniferRatio: number } | null,\n  maxTrees: number\n): TreeData[] {\n  if (!tileHint || tileHint.count <= 0) {\n    return [];\n  }\n\n  const seed = getTileSeed(tileX, tileY, tileZ) + 99999;\n  const random = seededRandom(seed);\n\n  const trees: TreeData[] = [];\n  const targetCount = Math.min(tileHint.count, maxTrees);\n  const coniferRatio = tileHint.coniferRatio;\n\n  for (let i = 0; i < targetCount; i++) {\n    const lng = bounds.west + random() * (bounds.east - bounds.west);\n    const lat = bounds.south + random() * (bounds.north - bounds.south);\n\n    const isConifer = random() < coniferRatio;\n    const leafType = isConifer ? 'needleleaved' : 'broadleaved';\n\n    // Variable height based on type\n    const baseHeight = isConifer ? 12 : 10;\n    const height = baseHeight + (random() - 0.5) * 8;\n\n    trees.push({\n      lat,\n      lng,\n      height: Math.max(4, Math.min(25, height)),\n      leafType,\n    });\n  }\n\n  return trees;\n}\n\n// ============================================================================\n// SPATIAL FILTERING\n// ============================================================================\n\ninterface PolygonWithBounds {\n  rings: number[][][];\n  minLng: number;\n  maxLng: number;\n  minLat: number;\n  maxLat: number;\n}\n\n// Road buffer distances by class (in meters)\nconst ROAD_BUFFER_METERS: Record<string, number> = {\n  motorway: 25,\n  trunk: 20,\n  primary: 15,\n  secondary: 12,\n  tertiary: 10,\n  residential: 6,\n  service: 4,\n  default: 8,\n};\n\ninterface RoadWithBounds {\n  feature: ParsedFeature;\n  bufferMeters: number;\n  minLng: number;\n  maxLng: number;\n  minLat: number;\n  maxLat: number;\n}\n\n/**\n * Preprocess polygons for fast filtering\n */\nfunction preprocessPolygons(features: ParsedFeature[]): PolygonWithBounds[] {\n  const result: PolygonWithBounds[] = [];\n\n  for (const feature of features) {\n    if (feature.type === 'Polygon') {\n      const rings = feature.coordinates as number[][][];\n      if (rings.length === 0 || rings[0].length === 0) continue;\n\n      const bounds = getPolygonBounds(rings[0]);\n      result.push({\n        rings,\n        minLng: bounds.minLng,\n        maxLng: bounds.maxLng,\n        minLat: bounds.minLat,\n        maxLat: bounds.maxLat,\n      });\n    } else if (feature.type === 'MultiPolygon') {\n      const polygons = feature.coordinates as number[][][][];\n      for (const rings of polygons) {\n        if (rings.length === 0 || rings[0].length === 0) continue;\n\n        const bounds = getPolygonBounds(rings[0]);\n        result.push({\n          rings,\n          minLng: bounds.minLng,\n          maxLng: bounds.maxLng,\n          minLat: bounds.minLat,\n          maxLat: bounds.maxLat,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Preprocess roads for fast filtering\n */\nfunction preprocessRoads(features: ParsedFeature[]): RoadWithBounds[] {\n  const result: RoadWithBounds[] = [];\n  // Convert max buffer to approximate degrees for bbox expansion\n  const bufferDegrees = 25 / 111320;\n\n  for (const feature of features) {\n    if (feature.type !== 'LineString' && feature.type !== 'MultiLineString') {\n      continue;\n    }\n\n    const roadClass = (feature.properties.class as string) || 'default';\n    const bufferMeters = ROAD_BUFFER_METERS[roadClass] || ROAD_BUFFER_METERS.default;\n\n    let minLng = Infinity, maxLng = -Infinity;\n    let minLat = Infinity, maxLat = -Infinity;\n\n    if (feature.type === 'LineString') {\n      const coords = feature.coordinates as number[][];\n      for (const [lng, lat] of coords) {\n        if (lng < minLng) minLng = lng;\n        if (lng > maxLng) maxLng = lng;\n        if (lat < minLat) minLat = lat;\n        if (lat > maxLat) maxLat = lat;\n      }\n    } else {\n      const lines = feature.coordinates as number[][][];\n      for (const line of lines) {\n        for (const [lng, lat] of line) {\n          if (lng < minLng) minLng = lng;\n          if (lng > maxLng) maxLng = lng;\n          if (lat < minLat) minLat = lat;\n          if (lat > maxLat) maxLat = lat;\n        }\n      }\n    }\n\n    result.push({\n      feature,\n      bufferMeters,\n      minLng: minLng - bufferDegrees,\n      maxLng: maxLng + bufferDegrees,\n      minLat: minLat - bufferDegrees,\n      maxLat: maxLat + bufferDegrees,\n    });\n  }\n\n  return result;\n}\n\nfunction pointInPolygonWithHoles(lng: number, lat: number, rings: number[][][]): boolean {\n  if (rings.length === 0) return false;\n\n  if (!pointInPolygon(lng, lat, rings[0])) {\n    return false;\n  }\n\n  for (let i = 1; i < rings.length; i++) {\n    if (pointInPolygon(lng, lat, rings[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPointInPolygons(lng: number, lat: number, polygons: PolygonWithBounds[]): boolean {\n  for (const polygon of polygons) {\n    if (lng < polygon.minLng || lng > polygon.maxLng || lat < polygon.minLat || lat > polygon.maxLat) {\n      continue;\n    }\n    if (pointInPolygonWithHoles(lng, lat, polygon.rings)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction pointToSegmentDistanceMeters(\n  px: number, py: number,\n  x1: number, y1: number,\n  x2: number, y2: number\n): number {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lengthSq = dx * dx + dy * dy;\n\n  let t = 0;\n  if (lengthSq > 0) {\n    t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));\n  }\n\n  const nearestX = x1 + t * dx;\n  const nearestY = y1 + t * dy;\n\n  const metersPerDegreeLat = 111320;\n  const metersPerDegreeLng = 111320 * Math.cos(py * Math.PI / 180);\n\n  const distLng = (px - nearestX) * metersPerDegreeLng;\n  const distLat = (py - nearestY) * metersPerDegreeLat;\n\n  return Math.sqrt(distLng * distLng + distLat * distLat);\n}\n\nfunction isPointNearRoad(lng: number, lat: number, roads: RoadWithBounds[]): boolean {\n  for (const road of roads) {\n    if (lng < road.minLng || lng > road.maxLng || lat < road.minLat || lat > road.maxLat) {\n      continue;\n    }\n\n    const feature = road.feature;\n    const bufferMeters = road.bufferMeters;\n\n    if (feature.type === 'LineString') {\n      const coords = feature.coordinates as number[][];\n      for (let i = 0; i < coords.length - 1; i++) {\n        const dist = pointToSegmentDistanceMeters(\n          lng, lat,\n          coords[i][0], coords[i][1],\n          coords[i + 1][0], coords[i + 1][1]\n        );\n        if (dist < bufferMeters) {\n          return true;\n        }\n      }\n    } else if (feature.type === 'MultiLineString') {\n      const lines = feature.coordinates as number[][][];\n      for (const line of lines) {\n        for (let i = 0; i < line.length - 1; i++) {\n          const dist = pointToSegmentDistanceMeters(\n            lng, lat,\n            line[i][0], line[i][1],\n            line[i + 1][0], line[i + 1][1]\n          );\n          if (dist < bufferMeters) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// ============================================================================\n// MAIN PROCESSING FUNCTION\n// ============================================================================\n\ninterface ProcessTreesPayloadInternal {\n  tileX: number;\n  tileY: number;\n  tileZ: number;\n  landcoverConfig: Record<string, LandcoverTreeConfig>;\n  maxProceduralTrees: number;\n  maxOSMDensityTrees: number;\n  basePMTilesUrl: string;\n  buildingsPMTilesUrl: string;\n  transportationPMTilesUrl: string;\n  treeTilesUrl: string;\n  treeTilesZoom: number;\n  elevationConfig?: ElevationConfig;\n  verticalExaggeration?: number;\n}\n\nasync function processTrees(payload: ProcessTreesPayloadInternal): Promise<ProcessTreesResult> {\n  const {\n    tileX,\n    tileY,\n    tileZ,\n    landcoverConfig,\n    maxProceduralTrees,\n    maxOSMDensityTrees,\n    basePMTilesUrl,\n    buildingsPMTilesUrl,\n    transportationPMTilesUrl,\n    treeTilesUrl,\n    // treeTilesZoom is ignored - we read the actual zoom from the file header\n    elevationConfig,\n    verticalExaggeration = 1.0,\n  } = payload;\n\n  // Initialize PMTiles and tree hints in parallel\n  await Promise.all([\n    initializePMTiles(basePMTilesUrl, buildingsPMTilesUrl, transportationPMTilesUrl),\n    loadTreeHints(treeTilesUrl),\n  ]);\n\n  // Look up tile hint from worker-loaded data (uses zoom from file header)\n  const tileHint = getTileHint(tileX, tileY, tileZ);\n\n  // Calculate bounds\n  const bounds = tileToBounds(tileX, tileY, tileZ);\n\n  // Fetch all required features in parallel\n  const [baseFeatures, waterFeatures, buildingFeatures, roadFeatures] = await Promise.all([\n    loadBaseTile(tileX, tileY, tileZ),\n    loadWaterPolygons(tileX, tileY, tileZ),\n    loadBuildingTile(tileX, tileY, tileZ),\n    loadTransportationTile(tileX, tileY, tileZ),\n  ]);\n\n  // Generate trees from both sources\n  const osmTrees = generateOSMDensityTrees(\n    tileX, tileY, tileZ,\n    bounds,\n    tileHint,\n    maxOSMDensityTrees\n  );\n\n  const proceduralTrees = generateProceduralTrees(\n    baseFeatures,\n    tileX, tileY, tileZ,\n    landcoverConfig,\n    maxProceduralTrees\n  );\n\n  let allTrees = [...osmTrees, ...proceduralTrees];\n  const totalBefore = allTrees.length;\n\n  // Preprocess polygons and roads for fast filtering\n  const processedWater = preprocessPolygons(waterFeatures);\n  const processedBuildings = preprocessPolygons(buildingFeatures);\n  const processedRoads = preprocessRoads(roadFeatures);\n\n  // Filter trees\n  allTrees = allTrees.filter(tree => {\n    const { lng, lat } = tree;\n\n    if (processedWater.length > 0 && isPointInPolygons(lng, lat, processedWater)) {\n      return false;\n    }\n\n    if (processedBuildings.length > 0 && isPointInPolygons(lng, lat, processedBuildings)) {\n      return false;\n    }\n\n    if (processedRoads.length > 0 && isPointNearRoad(lng, lat, processedRoads)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  // Compute terrain heights for filtered trees (HTTP cache should hit)\n  if (elevationConfig && allTrees.length > 0) {\n    await computeTerrainHeightsForTrees(allTrees, elevationConfig, verticalExaggeration);\n  }\n\n  return {\n    trees: allTrees,\n    stats: {\n      osmTrees: osmTrees.length,\n      proceduralTrees: proceduralTrees.length,\n      filteredOut: totalBefore - allTrees.length,\n    },\n  };\n}\n\n// ============================================================================\n// WORKER MESSAGE HANDLER\n// ============================================================================\n\ninterface TreeProcessRequest {\n  type: 'PROCESS_TREES';\n  id: string;\n  payload: ProcessTreesPayloadInternal;\n}\n\ninterface CapabilityRequest {\n  type: 'CAPABILITY_CHECK';\n  id: string;\n}\n\ntype WorkerRequest = TreeProcessRequest | CapabilityRequest;\n\nself.onmessage = async (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  if (request.type === 'CAPABILITY_CHECK') {\n    const response: WorkerResponse = {\n      type: 'CAPABILITY_CHECK_RESULT',\n      id: request.id,\n      supported: true,\n    };\n    self.postMessage(response);\n    return;\n  }\n\n  if (request.type === 'PROCESS_TREES') {\n    try {\n      const result = await processTrees(request.payload);\n      const response: WorkerResponse = {\n        type: 'PROCESS_TREES_RESULT',\n        id: request.id,\n        result,\n      };\n      self.postMessage(response);\n    } catch (error) {\n      const response: WorkerResponse = {\n        type: 'ERROR',\n        id: request.id,\n        error: (error as Error).message,\n      };\n      self.postMessage(response);\n    }\n    return;\n  }\n};\n\n// Signal ready\nself.postMessage({ type: 'READY' });\n"],"names":["u8","u16","i32","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","x","hMap","cd","mb","s","l","le","co","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","shft","slc","ec","err","ind","msg","nt","e","inflt","dat","st","buf","dict","sl","dl","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","n","lt","dt","t","lms","dms","lpos","sym","add","dsym","end","shift","dend","et","gzs","flg","zs","gzl","zls","inflateSync","data","opts","gunzipSync","unzlibSync","decompressSync","td","tds","B","u","W","E","y","w","z","f","h","N","k","q","G","ie","J","D","F","O","_","Y","Q","A","C","T","g","X","Z","U","I","K","R","M","P","H","Point","other","dx","dy","angle","cos","sin","VectorTileFeature","pbf","extent","keys","values","readFeature","lines","line","cmd","length","cmdLen","x1","x2","y1","y2","size","x0","y0","vtCoords","projectPoint","projectLine","geometry","points","coordinates","polygons","classifyRings","polygon","result","tag","feature","readTag","key","value","rings","len","ccw","area","signedArea","ring","sum","p1","p2","VectorTileLayer","readLayer","layer","readValueMessage","VectorTile","readTile","layers","SHIFT_LEFT_32","SHIFT_RIGHT_32","TEXT_DECODER_MIN_LENGTH","utf8TextDecoder","PBF_VARINT","PBF_FIXED64","PBF_BYTES","PBF_FIXED32","Pbf","readField","val","startPos","isSigned","readVarintRemainder","num","readUtf8","buffer","arr","min","writeBigVarint","str","writeUtf8","makeRoomForExtraLength","fn","obj","writePackedVarint","writePackedSVarint","writePackedBoolean","writePackedFloat","writePackedDouble","writePackedFixed32","writePackedSFixed32","writePackedFixed64","writePackedSFixed64","toNum","low","high","writeBigVarintLow","writeBigVarintHigh","lsb","extraLen","b0","bytesPerSequence","b1","b2","b3","lead","basePMTiles","buildingsPMTiles","transportationPMTiles","pmtilesInitialized","pmtilesInitPromise","basePMTilesUrl","buildingsPMTilesUrl","transportationPMTilesUrl","treeHintsData","treeHintsLoadPromise","treeHintsUrl","treeHintsZoom","packKey","packValue","count","coniferRatioUint8","unpackValue","packed","loadTreeHints","url","response","version","offset","tileCount","error","getTileHint","tileX","tileY","tileZ","hintsZoom","hx","hy","scale","initializePMTiles","baseUrl","buildingsUrl","transportUrl","PMTiles","fetchTileData","pmtiles","parseMVT","zoom","layerName","tile","features","allLayerNames","layerNames","name","geojson","tileToBounds","north","n2","south","west","east","elevationCache","lngLatToTile","lng","lat","latRad","elevationTileToBounds","decodeTerrarium","fetchElevationTile","config","cached","blob","bitmap","ctx","imageData","heights","bounds","bilinearInterpolate","gridX","gridY","gridSize","clampedX","clampedY","fx","fy","h00","h10","h01","h11","validCorners","avg","h00Safe","h10Safe","h01Safe","h11Safe","getTerrainHeightFromCache","relX","relY","height","prefetchElevationTilesForTrees","trees","neededTiles","tree","fetchPromises","tileKey","computeTerrainHeightsForTrees","verticalExaggeration","rawHeight","WATER_ZOOM_LEVELS","loadBaseTile","loadWaterPolygons","seenPolygons","fallbackZoom","fallbackX","fallbackY","allFeatures","coordHash","loadBuildingTile","loadTransportationTile","seededRandom","seed","state","getTileSeed","pointInPolygon","inside","xi","yi","xj","yj","calculatePolygonAreaMeters","centroidLat","metersPerDegreeLat","metersPerDegreeLng","getPolygonBounds","minLng","maxLng","minLat","maxLat","generateTreesInPolygon","_subtype","random","maxTrees","areaSqMeters","treesPerHectare","areaHectares","targetTreeCount","attempts","maxAttempts","leafType","generateProceduralTrees","landcoverConfig","allTrees","subtype","remainingSlots","remaining","generateOSMDensityTrees","tileHint","targetCount","coniferRatio","isConifer","ROAD_BUFFER_METERS","preprocessPolygons","preprocessRoads","bufferDegrees","roadClass","bufferMeters","coords","pointInPolygonWithHoles","isPointInPolygons","pointToSegmentDistanceMeters","px","py","lengthSq","nearestX","nearestY","distLng","distLat","isPointNearRoad","roads","road","processTrees","payload","maxProceduralTrees","maxOSMDensityTrees","treeTilesUrl","elevationConfig","baseFeatures","waterFeatures","buildingFeatures","roadFeatures","osmTrees","proceduralTrees","totalBefore","processedWater","processedBuildings","processedRoads","event","request"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}