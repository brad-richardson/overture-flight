{"version":3,"file":"building-geometry.worker-bwWCFT6z.js","sources":["../node_modules/earcut/src/earcut.js","../src/workers/building-geometry-builder.ts","../src/workers/building-geometry.worker.ts"],"sourcesContent":["\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n","/**\n * Building geometry builder for web workers\n * Creates 3D building geometry without Three.js ExtrudeGeometry dependency\n * Uses earcut for polygon triangulation (roof) and manual wall quad generation\n */\n\nimport earcut from 'earcut';\nimport type {\n  SceneOrigin,\n  BuildingFeatureInput,\n  CreateBuildingGeometryPayload,\n  CreateBuildingGeometryResult,\n  BuildingGeometryBuffers,\n} from './types.js';\n\n// LOD levels (must match buildings.ts)\n// LOD_HIGH = 0 (not used here, but defined in buildings.ts)\nconst LOD_MEDIUM = 1;\nconst LOD_LOW = 2;\nconst BUILDING_TERRAIN_OFFSET = 0.5;\nconst SLOPE_COMPENSATION_FACTOR = 0.3;\nconst MIN_BUILDING_AREA_FAR = 50; // m^2\n\n// Building colors by category (must match building-materials.ts)\nconst BUILDING_COLORS: Record<string, number> = {\n  residential: 0x9a9aa8,\n  commercial: 0x8888a0,\n  industrial: 0x707080,\n  retail: 0xa0a0b0,\n  office: 0x8080a0,\n  warehouse: 0x606070,\n  hospital: 0xc0c0d0,\n  school: 0xb8b0a0,\n  university: 0xb8b0a0,\n  religious: 0xd0c8c0,\n  government: 0xa0a0b0,\n  transportation: 0x808090,\n  default: 0x888899,\n};\n\n/**\n * Convert geographic coordinates to world coordinates\n */\nfunction geoToWorld(\n  lng: number,\n  lat: number,\n  altitude: number,\n  origin: SceneOrigin\n): { x: number; y: number; z: number } {\n  const x = (lng - origin.lng) * origin.metersPerDegLng;\n  const z = -(lat - origin.lat) * origin.metersPerDegLat;\n  const y = altitude;\n  return { x, y, z };\n}\n\n/**\n * Calculate signed area of a 2D polygon\n * Positive = clockwise, Negative = counter-clockwise\n */\nfunction calculatePolygonArea(points: { x: number; z: number }[]): number {\n  let area = 0;\n  for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n    area += (points[j].x + points[i].x) * (points[j].z - points[i].z);\n  }\n  return area / 2;\n}\n\n/**\n * Simplify polygon by removing vertices closer than tolerance\n */\nfunction simplifyPolygon(\n  points: { x: number; z: number }[],\n  tolerance: number\n): { x: number; z: number }[] {\n  if (points.length <= 4) return points;\n\n  const simplified: { x: number; z: number }[] = [points[0]];\n  let prevPoint = points[0];\n\n  for (let i = 1; i < points.length - 1; i++) {\n    const point = points[i];\n    const dx = point.x - prevPoint.x;\n    const dz = point.z - prevPoint.z;\n    const distance = Math.sqrt(dx * dx + dz * dz);\n\n    if (distance >= tolerance) {\n      simplified.push(point);\n      prevPoint = point;\n    }\n  }\n\n  // Always include last point\n  if (points.length > 1) {\n    simplified.push(points[points.length - 1]);\n  }\n\n  // Ensure minimum 3 points\n  if (simplified.length < 3) {\n    return points.length >= 3 ? points.slice(0, 3) : points.slice();\n  }\n\n  return simplified;\n}\n\n/**\n * Get building height from properties\n */\nfunction getBuildingHeight(\n  properties: BuildingFeatureInput['properties'],\n  defaultHeight: number\n): number {\n  // Try explicit height first\n  if (typeof properties.height === 'number' && properties.height > 0) {\n    return properties.height;\n  }\n\n  // Calculate from floors (3m per floor is typical)\n  if (typeof properties.num_floors === 'number' && properties.num_floors > 0) {\n    return properties.num_floors * 3;\n  }\n\n  return defaultHeight;\n}\n\n/**\n * Get building color from properties\n */\nfunction getBuildingColor(properties: BuildingFeatureInput['properties']): number {\n  const subtype = (properties.subtype || properties.class || '').toString().toLowerCase();\n\n  // Check for exact match\n  if (subtype in BUILDING_COLORS) {\n    return BUILDING_COLORS[subtype];\n  }\n\n  // Check for partial matches\n  if (subtype.includes('residential') || subtype.includes('house') || subtype.includes('apartment')) {\n    return BUILDING_COLORS.residential;\n  }\n  if (subtype.includes('commercial') || subtype.includes('retail') || subtype.includes('shop')) {\n    return BUILDING_COLORS.commercial;\n  }\n  if (subtype.includes('industrial') || subtype.includes('factory') || subtype.includes('warehouse')) {\n    return BUILDING_COLORS.industrial;\n  }\n  if (subtype.includes('office')) {\n    return BUILDING_COLORS.office;\n  }\n  if (subtype.includes('school') || subtype.includes('education')) {\n    return BUILDING_COLORS.school;\n  }\n  if (subtype.includes('hospital') || subtype.includes('medical')) {\n    return BUILDING_COLORS.hospital;\n  }\n  if (subtype.includes('church') || subtype.includes('religious') || subtype.includes('mosque') || subtype.includes('temple')) {\n    return BUILDING_COLORS.religious;\n  }\n\n  return BUILDING_COLORS.default;\n}\n\n/**\n * Generate building geometry for a single polygon\n * Returns null for invalid/too-small geometries\n */\nfunction generateBuildingGeometry(\n  coordinates: number[][][],\n  height: number,\n  minHeight: number,\n  color: number,\n  lodLevel: number,\n  terrainHeight: number,\n  terrainSlope: number,\n  verticalExaggeration: number,\n  origin: SceneOrigin\n): {\n  positions: number[];\n  normals: number[];\n  colors: number[];\n  indices: number[];\n} | null {\n  if (!coordinates || coordinates.length === 0) return null;\n\n  const outerRing = coordinates[0];\n  if (!outerRing || outerRing.length < 3) return null;\n\n  // Convert to world coordinates\n  // Use -world.z to match main thread coordinate convention (buildings.ts uses -world.z)\n  let points: { x: number; z: number }[] = [];\n  for (const coord of outerRing) {\n    const world = geoToWorld(coord[0], coord[1], 0, origin);\n    points.push({ x: world.x, z: -world.z });\n  }\n\n  // Remove duplicate last point if present\n  if (points.length > 1) {\n    const first = points[0];\n    const last = points[points.length - 1];\n    if (Math.abs(first.x - last.x) < 0.01 && Math.abs(first.z - last.z) < 0.01) {\n      points.pop();\n    }\n  }\n\n  if (points.length < 3) return null;\n\n  // Calculate area\n  const area = calculatePolygonArea(points);\n  if (Math.abs(area) < 1) return null;\n\n  // Skip small buildings at far distances\n  if (lodLevel === LOD_LOW && Math.abs(area) < MIN_BUILDING_AREA_FAR) {\n    return null;\n  }\n\n  // Apply simplification based on LOD\n  if (lodLevel === LOD_MEDIUM) {\n    points = simplifyPolygon(points, 2);\n  } else if (lodLevel === LOD_LOW) {\n    points = simplifyPolygon(points, 5);\n  }\n\n  if (points.length < 3) return null;\n\n  // Recalculate area after simplification\n  const finalArea = calculatePolygonArea(points);\n  if (Math.abs(finalArea) < 1) return null;\n\n  // Ensure counter-clockwise winding (for correct normals)\n  if (finalArea > 0) {\n    points.reverse();\n  }\n\n  // Calculate base and top Y positions\n  const baseY = terrainHeight * verticalExaggeration + BUILDING_TERRAIN_OFFSET - terrainSlope * SLOPE_COMPENSATION_FACTOR;\n  const topY = baseY + height;\n  const bottomY = baseY + minHeight; // For buildings with min_height (floating bases)\n\n  // Flatten points for earcut (x, z format)\n  const flatCoords: number[] = [];\n  for (const p of points) {\n    flatCoords.push(p.x, p.z);\n  }\n\n  // Process holes (skip for LOW LOD)\n  const holes: number[] = [];\n  if (lodLevel !== LOD_LOW && coordinates.length > 1) {\n    for (let i = 1; i < coordinates.length; i++) {\n      const holeRing = coordinates[i];\n      if (!holeRing || holeRing.length < 3) continue;\n\n      holes.push(flatCoords.length / 2); // Start index of hole\n\n      // Use -world.z to match main thread coordinate convention\n      let holePoints: { x: number; z: number }[] = [];\n      for (const coord of holeRing) {\n        const world = geoToWorld(coord[0], coord[1], 0, origin);\n        holePoints.push({ x: world.x, z: -world.z });\n      }\n\n      // Remove duplicate last point\n      if (holePoints.length > 1) {\n        const first = holePoints[0];\n        const last = holePoints[holePoints.length - 1];\n        if (Math.abs(first.x - last.x) < 0.01 && Math.abs(first.z - last.z) < 0.01) {\n          holePoints.pop();\n        }\n      }\n\n      // Simplify holes for medium LOD\n      if (lodLevel === LOD_MEDIUM && holePoints.length > 4) {\n        holePoints = simplifyPolygon(holePoints, 2);\n      }\n\n      // Holes should be clockwise (opposite winding)\n      const holeArea = calculatePolygonArea(holePoints);\n      if (holeArea < 0) {\n        holePoints.reverse();\n      }\n\n      for (const p of holePoints) {\n        flatCoords.push(p.x, p.z);\n      }\n    }\n  }\n\n  // Triangulate roof using earcut\n  const roofIndices = earcut(flatCoords, holes, 2);\n  if (roofIndices.length === 0) return null;\n\n  // Extract vertex positions from flatCoords\n  const vertexCount = flatCoords.length / 2;\n  const roofVertices: { x: number; z: number }[] = [];\n  for (let i = 0; i < vertexCount; i++) {\n    roofVertices.push({\n      x: flatCoords[i * 2],\n      z: flatCoords[i * 2 + 1],\n    });\n  }\n\n  // Build geometry buffers\n  const positions: number[] = [];\n  const normals: number[] = [];\n  const colors: number[] = [];\n  const indices: number[] = [];\n\n  // Extract RGB from hex color\n  const r = ((color >> 16) & 0xff) / 255;\n  const g = ((color >> 8) & 0xff) / 255;\n  const b = (color & 0xff) / 255;\n\n  // === ROOF (top face) ===\n  const roofStartIndex = positions.length / 3;\n  for (const v of roofVertices) {\n    positions.push(v.x, topY, v.z);\n    normals.push(0, 1, 0); // Up\n    colors.push(r, g, b);\n  }\n  for (const idx of roofIndices) {\n    indices.push(roofStartIndex + idx);\n  }\n\n  // === BOTTOM (base face, if minHeight > 0 for floating buildings) ===\n  if (minHeight > 0) {\n    const bottomStartIndex = positions.length / 3;\n    for (const v of roofVertices) {\n      positions.push(v.x, bottomY, v.z);\n      normals.push(0, -1, 0); // Down\n      colors.push(r * 0.7, g * 0.7, b * 0.7); // Darker\n    }\n    // Reverse winding for bottom face\n    for (let i = roofIndices.length - 1; i >= 0; i--) {\n      indices.push(bottomStartIndex + roofIndices[i]);\n    }\n  }\n\n  // === WALLS ===\n  // Use only outer ring points for walls (index 0 to points.length)\n  const outerPointCount = points.length;\n  const wallDarkening = 0.85; // Slightly darker walls\n\n  for (let i = 0; i < outerPointCount; i++) {\n    const p0 = points[i];\n    const p1 = points[(i + 1) % outerPointCount];\n\n    // Calculate wall normal (perpendicular to wall segment)\n    const dx = p1.x - p0.x;\n    const dz = p1.z - p0.z;\n    const len = Math.sqrt(dx * dx + dz * dz);\n    if (len < 0.01) continue; // Skip degenerate segments\n\n    // Normal pointing outward (right-hand rule)\n    const nx = -dz / len;\n    const nz = dx / len;\n\n    const wallStartIndex = positions.length / 3;\n\n    // Four vertices per wall quad: bottom-left, bottom-right, top-right, top-left\n    // Using bottomY for base (or baseY if no minHeight)\n    const wallBaseY = minHeight > 0 ? bottomY : baseY;\n\n    positions.push(p0.x, wallBaseY, p0.z); // 0: bottom-left\n    positions.push(p1.x, wallBaseY, p1.z); // 1: bottom-right\n    positions.push(p1.x, topY, p1.z);      // 2: top-right\n    positions.push(p0.x, topY, p0.z);      // 3: top-left\n\n    for (let j = 0; j < 4; j++) {\n      normals.push(nx, 0, nz);\n      colors.push(r * wallDarkening, g * wallDarkening, b * wallDarkening);\n    }\n\n    // Two triangles with CCW winding when viewed from outside: (0,3,2) and (0,2,1)\n    indices.push(wallStartIndex + 0, wallStartIndex + 3, wallStartIndex + 2);\n    indices.push(wallStartIndex + 0, wallStartIndex + 2, wallStartIndex + 1);\n  }\n\n  // Add walls for holes (only for higher LOD)\n  if (lodLevel !== LOD_LOW && coordinates.length > 1) {\n    let holeStartIdx = outerPointCount;\n    for (let h = 1; h < coordinates.length; h++) {\n      const holeRing = coordinates[h];\n      if (!holeRing || holeRing.length < 3) continue;\n\n      // Get hole vertices (already processed above)\n      const holeVertexCount = holeRing.length - (\n        holeRing.length > 1 &&\n        Math.abs(holeRing[0][0] - holeRing[holeRing.length - 1][0]) < 0.0001 &&\n        Math.abs(holeRing[0][1] - holeRing[holeRing.length - 1][1]) < 0.0001\n          ? 1 : 0\n      );\n\n      for (let i = 0; i < Math.min(holeVertexCount, roofVertices.length - holeStartIdx); i++) {\n        const idx0 = holeStartIdx + i;\n        const idx1 = holeStartIdx + ((i + 1) % holeVertexCount);\n        if (idx0 >= roofVertices.length || idx1 >= roofVertices.length) break;\n\n        const p0 = roofVertices[idx0];\n        const p1 = roofVertices[idx1];\n\n        const dx = p1.x - p0.x;\n        const dz = p1.z - p0.z;\n        const len = Math.sqrt(dx * dx + dz * dz);\n        if (len < 0.01) continue;\n\n        // Normal pointing inward for holes (opposite direction)\n        const nx = dz / len;\n        const nz = -dx / len;\n\n        const wallStartIndex = positions.length / 3;\n        const wallBaseY = minHeight > 0 ? bottomY : baseY;\n\n        positions.push(p0.x, wallBaseY, p0.z);\n        positions.push(p1.x, wallBaseY, p1.z);\n        positions.push(p1.x, topY, p1.z);\n        positions.push(p0.x, topY, p0.z);\n\n        for (let j = 0; j < 4; j++) {\n          normals.push(nx, 0, nz);\n          colors.push(r * wallDarkening, g * wallDarkening, b * wallDarkening);\n        }\n\n        // Two triangles with CCW winding when viewed from inside (hole walls face inward)\n        indices.push(wallStartIndex + 0, wallStartIndex + 3, wallStartIndex + 2);\n        indices.push(wallStartIndex + 0, wallStartIndex + 2, wallStartIndex + 1);\n      }\n\n      holeStartIdx += holeVertexCount;\n    }\n  }\n\n  return { positions, normals, colors, indices };\n}\n\n/**\n * Build geometry for all buildings in a tile\n * Returns merged geometry buffers ready for GPU upload\n */\nexport function buildBuildingGeometry(\n  payload: CreateBuildingGeometryPayload\n): CreateBuildingGeometryResult {\n  const {\n    features,\n    origin,\n    lodLevel,\n    defaultHeight,\n    terrainHeights,\n    verticalExaggeration,\n  } = payload;\n\n  const allPositions: number[] = [];\n  const allNormals: number[] = [];\n  const allColors: number[] = [];\n  const allIndices: number[] = [];\n  let vertexOffset = 0;\n\n  let buildingsProcessed = 0;\n  let buildingsSkipped = 0;\n\n  for (let i = 0; i < features.length; i++) {\n    const feature = features[i];\n\n    // Skip underground buildings\n    if (feature.properties.is_underground) {\n      buildingsSkipped++;\n      continue;\n    }\n\n    // Get building properties\n    const height = getBuildingHeight(feature.properties, defaultHeight);\n    const minHeight = typeof feature.properties.min_height === 'number'\n      ? feature.properties.min_height : 0;\n    const color = getBuildingColor(feature.properties);\n\n    // Get terrain height for this building\n    const terrainData = terrainHeights?.[i];\n    const terrainHeight = terrainData ? terrainData[0] : 0;\n    const terrainSlope = terrainData ? (terrainData[1] - terrainData[0]) : 0;\n\n    // Process polygon(s)\n    const polygons = feature.type === 'Polygon'\n      ? [feature.coordinates as number[][][]]\n      : feature.coordinates as number[][][][];\n\n    for (const polygon of polygons) {\n      try {\n        const geom = generateBuildingGeometry(\n          polygon,\n          height,\n          minHeight,\n          color,\n          lodLevel,\n          terrainHeight,\n          terrainSlope,\n          verticalExaggeration,\n          origin\n        );\n\n        if (geom) {\n          // Append positions\n          for (const v of geom.positions) {\n            allPositions.push(v);\n          }\n\n          // Append normals\n          for (const n of geom.normals) {\n            allNormals.push(n);\n          }\n\n          // Append colors\n          for (const c of geom.colors) {\n            allColors.push(c);\n          }\n\n          // Append indices with offset\n          for (const idx of geom.indices) {\n            allIndices.push(idx + vertexOffset);\n          }\n\n          vertexOffset += geom.positions.length / 3;\n          buildingsProcessed++;\n        } else {\n          buildingsSkipped++;\n        }\n      } catch {\n        buildingsSkipped++;\n      }\n    }\n  }\n\n  // Create result\n  if (allPositions.length === 0) {\n    return {\n      geometry: null,\n      stats: {\n        buildingsProcessed: 0,\n        buildingsSkipped: buildingsSkipped,\n        totalVertices: 0,\n        totalTriangles: 0,\n      },\n    };\n  }\n\n  const geometry: BuildingGeometryBuffers = {\n    positions: new Float32Array(allPositions),\n    normals: new Float32Array(allNormals),\n    colors: new Float32Array(allColors),\n    indices: new Uint32Array(allIndices),\n  };\n\n  return {\n    geometry,\n    stats: {\n      buildingsProcessed,\n      buildingsSkipped,\n      totalVertices: allPositions.length / 3,\n      totalTriangles: allIndices.length / 3,\n    },\n  };\n}\n\n/**\n * Get transferable buffers from building geometry result\n */\nexport function getBuildingTransferables(result: CreateBuildingGeometryResult): ArrayBuffer[] {\n  if (!result.geometry) return [];\n\n  return [\n    result.geometry.positions.buffer as ArrayBuffer,\n    result.geometry.normals.buffer as ArrayBuffer,\n    result.geometry.colors.buffer as ArrayBuffer,\n    result.geometry.indices.buffer as ArrayBuffer,\n  ];\n}\n","/**\n * Web Worker for building geometry creation\n * Offloads CPU-intensive building extrusion from the main thread\n *\n * Benefits:\n * - No main thread blocking during building geometry generation\n * - Uses earcut for fast polygon triangulation (no Three.js dependency)\n * - Transfers Float32Array buffers (zero-copy)\n */\n\nimport type { WorkerRequest, WorkerResponse, CreateBuildingGeometryPayload } from './types.js';\nimport { buildBuildingGeometry, getBuildingTransferables } from './building-geometry-builder.js';\n\n/**\n * Handle incoming messages from the main thread\n */\nself.onmessage = (event: MessageEvent<WorkerRequest>) => {\n  const request = event.data;\n\n  try {\n    switch (request.type) {\n      case 'CAPABILITY_CHECK': {\n        // Building geometry workers don't need special capabilities\n        const response: WorkerResponse = {\n          type: 'CAPABILITY_CHECK_RESULT',\n          id: request.id,\n          supported: true,\n        };\n        self.postMessage(response);\n        break;\n      }\n\n      case 'CREATE_BUILDING_GEOMETRY': {\n        const payload = request.payload as CreateBuildingGeometryPayload;\n\n        // Build geometry buffers\n        const result = buildBuildingGeometry(payload);\n\n        // Get transferable buffers for zero-copy transfer\n        const transferables = getBuildingTransferables(result);\n\n        const response: WorkerResponse = {\n          type: 'CREATE_BUILDING_GEOMETRY_RESULT',\n          id: request.id,\n          result,\n        };\n\n        // Transfer ownership of buffers (zero-copy)\n        self.postMessage(response, { transfer: transferables });\n        break;\n      }\n\n      default: {\n        const response: WorkerResponse = {\n          type: 'ERROR',\n          id: (request as { id?: string }).id || 'unknown',\n          error: `Building geometry worker received unsupported request type: ${(request as { type?: string }).type}`,\n        };\n        self.postMessage(response);\n      }\n    }\n  } catch (error) {\n    const response: WorkerResponse = {\n      type: 'ERROR',\n      id: request.id,\n      error: error instanceof Error ? error.message : 'Unknown error in building geometry worker',\n    };\n    self.postMessage(response);\n  }\n};\n\n// Signal that worker is ready\nself.postMessage({ type: 'READY' });\n"],"names":["earcut","data","holeIndices","dim","hasHoles","outerLen","outerNode","linkedList","triangles","minX","minY","invSize","eliminateHoles","maxX","maxY","i","x","y","earcutLinked","start","end","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","p","again","area","ear","pass","indexCurve","stop","prev","next","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangleExceptFirst","minZ","zOrder","maxZ","n","intersects","locallyInside","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","compareXYSlope","eliminateHole","result","aSlope","bSlope","hole","bridge","findHoleBridge","bridgeReverse","hx","hy","qx","m","mx","my","tanMin","pointInTriangle","tan","sectorContainsSector","sortLinked","numMerges","inSize","e","tail","q","pSize","qSize","leftmost","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","num","inside","a2","createNode","b2","an","bp","sum","j","LOD_MEDIUM","LOD_LOW","BUILDING_TERRAIN_OFFSET","SLOPE_COMPENSATION_FACTOR","MIN_BUILDING_AREA_FAR","BUILDING_COLORS","geoToWorld","lng","lat","altitude","origin","z","calculatePolygonArea","points","simplifyPolygon","tolerance","simplified","prevPoint","point","dx","dz","getBuildingHeight","properties","defaultHeight","getBuildingColor","subtype","generateBuildingGeometry","coordinates","height","minHeight","color","lodLevel","terrainHeight","terrainSlope","verticalExaggeration","outerRing","coord","world","first","finalArea","baseY","topY","bottomY","flatCoords","holes","holeRing","holePoints","roofIndices","vertexCount","roofVertices","positions","normals","colors","indices","g","roofStartIndex","v","idx","bottomStartIndex","outerPointCount","wallDarkening","p0","nx","nz","wallStartIndex","wallBaseY","holeStartIdx","h","holeVertexCount","idx0","idx1","buildBuildingGeometry","payload","features","terrainHeights","allPositions","allNormals","allColors","allIndices","vertexOffset","buildingsProcessed","buildingsSkipped","feature","terrainData","polygons","polygon","geom","getBuildingTransferables","event","request","response","transferables","error"],"mappings":"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","x_google_ignoreList":[0]}